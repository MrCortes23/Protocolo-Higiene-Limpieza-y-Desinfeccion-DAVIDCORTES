<script>
// ==================== VARIABLES GLOBALES ====================
let currentUser = null;
let maquinasData = [];
let currentMaquinaId = null;
let currentElementoId = null;
let currentElementoNombre = null;
let currentMaquinaNombre = null;
let selectedElementosConfig = {};
let pendingCheckboxData = null;
let currentElementoTiposLimpieza = [];
let pendingValidation = false;
let elementosSeleccionados = new Set(); 
let elementosSeleccionadosData = {};
let isRenderingSidebar = false;
let estadosElementosCache = {}; 

// ==================== FUNCIONES DE UTILIDAD ====================
function showLoading() {
  document.getElementById('loading-overlay').classList.remove('hidden');
}

function hideLoading() {
  document.getElementById('loading-overlay').classList.add('hidden');
}

function showError(elementId, message) {
  const element = document.getElementById(elementId);
  if (element) {
    element.textContent = message;
    element.classList.remove('hidden');
  }
}

function hideError(elementId) {
  const element = document.getElementById(elementId);
  if (element) {
    element.classList.add('hidden');
  }
}

// ==================== AUTENTICACI√ìN ====================
function handleLogin() {
  console.log('üîê Intentando login...');
  const cedula = document.getElementById('cedula-input').value.trim();
  
  if (!cedula) {
    showError('login-error', 'Por favor ingrese su c√©dula');
    return;
  }
  
  hideError('login-error');
  showLoading();
  
  console.log('üì§ Enviando c√©dula:', cedula);
  
  google.script.run
    .withSuccessHandler(onLoginSuccess)
    .withFailureHandler(onLoginError)
    .autenticarUsuario(cedula);
}

function onLoginSuccess(result) {
  hideLoading();
  console.log('üì• Respuesta login:', result);
  
  if (result && result.success) {
    currentUser = result.usuario;
    
    // Limpiar y actualizar UI de usuario
    const userNameDisplay = document.getElementById('user-name-display');
    userNameDisplay.textContent = currentUser.nombre;
    userNameDisplay.innerHTML = ''; // Limpiar contenido previo
    userNameDisplay.appendChild(document.createTextNode(currentUser.nombre));
    
    actualizarIndicadorProceso();
    
    // Cambiar a vista dashboard
    document.getElementById('login-view').classList.add('hidden');
    document.getElementById('dashboard-view').classList.remove('hidden');
    
    // Resetear pesta√±as a la principal (avances o proceso seg√∫n rol)
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
    
    // Ocultar tab de planeaciones si no es jefe
    const tabPlaneacion = document.getElementById('tab-planeacion');
    if (currentUser.rol !== 'jefe') {
      tabPlaneacion.classList.add('hidden');
      
      // Mostrar tab de avances por defecto para operarios
      document.getElementById('tab-avances').classList.add('active');
      document.getElementById('content-avances').classList.remove('hidden');
    } else {
      // Mostrar tab de planeaci√≥n por defecto para jefes
      tabPlaneacion.classList.remove('hidden');
      tabPlaneacion.classList.add('active');
      document.getElementById('content-planeacion').classList.remove('hidden');
    }
    
    // Limpiar datos previos
    resetearDatos();
    
    // Cargar datos iniciales
    loadInitialData();
    
    showAlert("success", "Sesi√≥n iniciada", `Bienvenido/a ${currentUser.nombre}`);
  } else {
    showError('login-error', result ? result.message : 'Error de autenticaci√≥n');
  }
}

function onLoginError(error) {
  hideLoading();
  console.error('‚ùå Error login:', error);
  showError('login-error', 'Error de conexi√≥n. Intente nuevamente.');
}

function handleLogout() {
  console.log('üö™ Cerrando sesi√≥n...');
  
  // Resetear todas las variables globales
  currentUser = null;
  maquinasData = [];
  currentMaquinaId = null;
  currentElementoId = null;
  currentElementoNombre = null;
  currentMaquinaNombre = null;
  selectedElementosConfig = {};
  pendingCheckboxData = null;
  currentElementoTiposLimpieza = [];
  pendingValidation = false;
  estadosElementosCache = {};
  
  // Limpiar todos los contenedores de UI
  const containersToClear = [
    'maquinas-menu',
    'maquinas-tree',
    'elementos-config-list',
    'avances-grid',
    'proceso-content',
    'planeaciones-grid',
    'limpieza-sections'
  ];
  
  containersToClear.forEach(id => {
    const container = document.getElementById(id);
    if (container) container.innerHTML = '';
  });
  
  // Resetear formularios
  const forms = document.querySelectorAll('input, textarea, select');
  forms.forEach(form => {
    if (form.type !== 'button' && form.type !== 'submit') {
      form.value = '';
      form.checked = false;
    }
  });
  
  // Resetear select de frecuencia
  const selectFrecuencia = document.getElementById('select-frecuencia');
  if (selectFrecuencia) selectFrecuencia.value = 'Mensual';
  
  // Desmarcar todos los checkboxes del √°rbol
  document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
    checkbox.checked = false;
    checkbox.indeterminate = false;
  });
  
  // Remover clases selected de elementos del √°rbol
  document.querySelectorAll('.tree-elemento.selected').forEach(el => {
    el.classList.remove('selected');
  });
  
  // Resetear pesta√±as
  document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
  
  // Resetear elemento activo en sidebar
  document.querySelectorAll('.elemento-item.active').forEach(el => {
    el.classList.remove('active');
  });
  
  // Resetear indicador de proceso
  const procesoIndicator = document.getElementById('proceso-indicator');
  if (procesoIndicator) procesoIndicator.innerHTML = '';
  
  // Ocultar botones de validaci√≥n
  const btnValidarJefe = document.getElementById('btn-validar-jefe');
  const btnFinalizar = document.getElementById('btn-finalizar');
  if (btnValidarJefe) btnValidarJefe.classList.add('hidden');
  if (btnFinalizar) btnFinalizar.classList.add('hidden');
  
  // Cambiar vistas
  document.getElementById('dashboard-view').classList.add('hidden');
  document.getElementById('login-view').classList.remove('hidden');
  
  // Resetear campo de c√©dula
  const cedulaInput = document.getElementById('cedula-input');
  if (cedulaInput) {
    cedulaInput.value = '';
    cedulaInput.focus(); // Poner foco en el campo
  }
  
  // Mostrar mensaje de despedida
  showAlert("info", "Sesi√≥n cerrada", "Ha cerrado sesi√≥n correctamente", 3000);
  
  console.log('‚úÖ Sesi√≥n cerrada completamente');
}

function resetearDatos() {
  // Resetear datos de m√°quinas
  maquinasData = [];
  
  // Resetear configuraciones seleccionadas
  selectedElementosConfig = {};
  
  // Resetear cache de estados
  estadosElementosCache = {};
  
  // Resetear datos de elemento actual
  currentMaquinaId = null;
  currentElementoId = null;
  currentElementoNombre = null;
  currentMaquinaNombre = null;
  currentElementoTiposLimpieza = [];
  
  // Resetear estado de validaci√≥n pendiente
  pendingValidation = false;
  pendingCheckboxData = null;
  
  console.log('üîÑ Datos reseteados para nueva sesi√≥n');
}

// ==================== CARGA INICIAL ====================
function loadInitialData() {
  showLoading();
  
  // Primero cargar planeaciones para saber qu√© elementos tienen planeaci√≥n
  verificarElementosPlaneados().then(() => {
    // Luego cargar m√°quinas con elementos
    google.script.run
      .withSuccessHandler(onMaquinasLoaded)
      .withFailureHandler(onDataError)
      .obtenerMaquinasConElementos(currentUser.proceso);
  });
}

function onMaquinasLoaded(result) {
  if (result && result.success) {
    maquinasData = result.maquinas || [];
    
    // Limpiar datos duplicados antes de renderizar
    limpiarDatosDuplicados();
    
    // Cargar estados y luego renderizar
    cargarEstadosElementos().then(() => {
      renderSidebarMaquinas();
      
      // Solo renderizar √°rbol de planeaci√≥n si es jefe
      if (currentUser.rol === 'jefe') {
        renderMaquinasTree();
      }
      
      loadEstadisticas();
      hideLoading();
    });
  } else {
    hideLoading();
    console.error('Error cargando m√°quinas:', result ? result.message : 'Sin respuesta');
    maquinasData = [];
    renderSidebarMaquinas();
  }
}

function onDataError(error) {
  hideLoading();
  console.error('Error cargando datos:', error);
}

// ==================== SIDEBAR ====================
function renderSidebarMaquinas() {
    // Si ya se est√° renderizando, salir
    if (isRenderingSidebar) {
        console.log('‚è∏Ô∏è  Ya se est√° renderizando el sidebar, omitiendo...');
        return;
    }
    
    isRenderingSidebar = true;
    
    const container = document.getElementById('maquinas-menu');
    container.innerHTML = '';
    
    // A√±adir panel de acciones
    const actionPanel = document.createElement('div');
    actionPanel.className = 'sidebar-actions-panel';
    actionPanel.innerHTML = `
        <div class="sidebar-action-item" onclick="mostrarPanelLimpiezaMasiva()">
            <i class="fas fa-broom"></i>
            <span>Limpieza</span>
            <span id="selected-count" class="selected-count">${elementosSeleccionados.size}</span>
        </div>
        <div class="selection-actions">
            <button class="selection-btn" onclick="seleccionarTodosElementosPendientes()" title="Seleccionar todos los pendientes">
                <i class="fas fa-check-square"></i>
            </button>
            <button class="selection-btn" onclick="deseleccionarTodosElementos()" title="Deseleccionar todos">
                <i class="fas fa-square"></i>
            </button>
        </div>
    `;
    container.appendChild(actionPanel);
    
    if (!maquinasData || maquinasData.length === 0) {
        container.innerHTML += '<p style="font-size: 12px; color: #9CA3AF; padding: 10px;">No hay m√°quinas disponibles</p>';
        return;
    }
    
    // Primero cargar todos los estados de elementos
    cargarEstadosElementos().then(() => {
        // Usar el ID de la m√°quina directamente, no maquinaIndex
        maquinasData.forEach(maquina => {
            const maquinaDiv = document.createElement('div');
            maquinaDiv.className = 'submenu-wrapper';
            
            // Usar el ID real de la m√°quina en lugar de un √≠ndice
            const submenuId = 'submenu-sidebar-' + maquina.id;
            const estadoMaquina = determinarEstadoMaquina(maquina.id);
            
            // Generar HTML para componentes y elementos
            let componentesHtml = '';
            
            if (maquina.componentes && maquina.componentes.length > 0) {
                componentesHtml = maquina.componentes.map(componente => {
                    const componenteSubmenuId = `comp-${maquina.id}-${componente.id}`;
                    const estadoComponente = determinarEstadoComponente(maquina.id, componente.id);
                    
                    // Filtrar elementos por responsable seg√∫n el rol
                    let elementosFiltrados = [];
                      if (componente.elementos) {
                          elementosFiltrados = componente.elementos.filter(elem => {
                              // Si el usuario es jefe, mostrar todos los elementos
                              if (currentUser.rol.toLowerCase() === 'jefe') {
                                  return true;
                              }
                              
                              // Obtener responsable del elemento
                              const responsableElemento = obtenerResponsableElemento(elem.id);
                              const rolUsuario = currentUser.rol.toLowerCase();
                              const tienePlaneacion = tienePlaneacionActiva(elem.id);
                              
                              // Si el elemento NO tiene planeaci√≥n, siempre mostrarlo (para todos los roles)
                              if (!tienePlaneacion) {
                                  return true;
                              }
                              
                              // Si el usuario es operario, mostrar solo elementos de operario O sin planeaci√≥n
                              if (rolUsuario === 'operario') {
                                  return responsableElemento === 'OPERARIO';
                              }
                              
                              // Si el usuario es contratista, mostrar solo elementos de contratista O sin planeaci√≥n
                              if (rolUsuario === 'contratista') {
                                  return responsableElemento === 'CONTRATISTA';
                              }
                              
                              // Por defecto, mostrar todos
                              return true;
                          });
                      }
                    
                    // Si no hay elementos despu√©s de filtrar, no mostrar el componente
                    if (elementosFiltrados.length === 0 && currentUser.rol !== 'jefe') {
                        return '';
                    }
                    
                    const elementosHtml = elementosFiltrados.map((elem) => {
                    const estadoElemento = determinarEstadoElemento(elem.id);
                    const puedeSeleccionar = puedeSeleccionarParaLimpiezaMasiva(elem.id);
                    const tienePlaneacion = tienePlaneacionActiva(elem.id); // ‚Üê Esta funci√≥n ya existe
                    const claseEstado = `estado-${estadoElemento}`;
                    const isSelected = elementosSeleccionados.has(elem.id);

                    // Determinar icono seg√∫n estado
                    let icono = '';
                    let color = '#9ca3af';
                    let tooltip = '';

                    if (!tienePlaneacion) {
                        icono = 'fa-calendar-times';
                        tooltip = 'Elemento sin planeaci√≥n';
                        color = '#9ca3af'; // Gris para elementos sin planeaci√≥n
                    } else if (estadoElemento === 'terminado' || estadoElemento === 'en-proceso') {
                        icono = 'fa-check-circle';
                        color = estadoElemento === 'terminado' ? '#10b981' : '#f59e0b';
                        tooltip = estadoElemento === 'terminado' ? 'Limpieza completada' : 'Limpieza en proceso';
                    } else if (estadoElemento === 'empezado') {
                        icono = 'fa-spinner';
                        color = '#f59e0b';
                        tooltip = 'Limpieza iniciada';
                    } else if (estadoElemento === 'pendiente') {
                        icono = 'fa-clock';
                        color = '#ef4444';
                        tooltip = 'Limpieza pendiente';
                    } else {
                        icono = 'fa-question-circle';
                        tooltip = 'Estado desconocido';
                    }

                    // SOLO mostrar badge de responsable si el elemento tiene planeaci√≥n
                    let badgeResponsable = '';
                    if (tienePlaneacion) {
                        const responsable = obtenerResponsableElemento(elem.id);
                        badgeResponsable = `<span class="responsable-badge ${responsable.toLowerCase()}">${responsable === 'OPERARIO' ? 'OP' : 'CT'}</span>`;
                    }

                    // Solo mostrar checkbox si el elemento PUEDE seleccionarse para limpieza masiva
                    if (puedeSeleccionar) {
                        return `
                            <div class="elemento-item ${claseEstado} ${isSelected ? 'selected' : ''} seleccionable" 
                                onclick="handleElementoSelection('${elem.id}', '${maquina.id}', '${elem.nombre}', event)"
                                title="${tooltip}${tienePlaneacion ? ' - Responsable: ' + obtenerResponsableElemento(elem.id) : ''}">
                                <input type="checkbox" 
                                    class="sidebar-checkbox" 
                                    id="sidebar-check-${elem.id}"
                                    ${isSelected ? 'checked' : ''}
                                    onclick="event.stopPropagation(); handleCheckboxClick('${elem.id}', '${maquina.id}', '${elem.nombre}', event)">
                                <span class="elemento-nombre">${elem.nombre}</span>
                                ${badgeResponsable}
                                <span class="elemento-indicador">
                                    <i class="fas ${icono}" style="color: ${color}; font-size: 10px;"></i>
                                </span>
                            </div>
                        `;
                    } else {
                        return `
                            <div class="elemento-item ${claseEstado} no-seleccionable" 
                                onclick="selectElementoFromSidebar('${maquina.id}', '${elem.id}', '${maquina.nombre}', '${elem.nombre}', '${componente.nombre}')"
                                title="${tooltip}${tienePlaneacion ? ' - Responsable: ' + obtenerResponsableElemento(elem.id) : ''} - No se puede seleccionar para limpieza masiva">
                                <span class="elemento-nombre">${elem.nombre}</span>
                                ${badgeResponsable}
                                <span class="elemento-indicador">
                                    <i class="fas ${icono}" style="color: ${color}; font-size: 10px;"></i>
                                </span>
                            </div>
                        `;
                    }
                }).join('');
                    
                    return `
                        <div class="submenu-wrapper">
                            <div class="submenu-item componente-item ${estadoComponente}" onclick="toggleSubmenu('${componenteSubmenuId}')">
                                <span>${componente.nombre}</span>
                                <span class="menu-arrow" id="arrow-${componenteSubmenuId}">‚ñº</span>
                            </div>
                            <div id="${componenteSubmenuId}" class="submenu-content hidden">
                                ${elementosHtml}
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            // Si no hay componentes despu√©s de filtrar, no mostrar la m√°quina
            if (componentesHtml === '' && currentUser.rol !== 'jefe') {
                return;
            }
            
            maquinaDiv.innerHTML = `
                <div class="submenu-item maquina-item ${estadoMaquina}" onclick="toggleSubmenu('${submenuId}')">
                    <span>${maquina.nombre}</span>
                    <span class="menu-arrow" id="arrow-${submenuId}">‚ñº</span>
                </div>
                <div id="${submenuId}" class="submenu-content hidden">
                    ${componentesHtml}
                </div>
            `;
            container.appendChild(maquinaDiv);
        });

        isRenderingSidebar = false;
        actualizarContadorSeleccionados();
    });
}

function tienePlaneacionActiva(elementoId) {
    const estado = determinarEstadoElemento(elementoId);
    
    // Elemento tiene planeaci√≥n activa si tiene alg√∫n estado diferente de 'no-planeado'
    return estado !== 'no-planeado';
}

function verificarElementosPlaneados() {
    return new Promise((resolve) => {
        // Obtener todas las planeaciones
        google.script.run
            .withSuccessHandler(function(result) {
                const elementosPlaneados = new Set();
                
                if (result && result.success && result.planeaciones) {
                    result.planeaciones.forEach(planeacion => {
                        if (planeacion.elementosConfig && Array.isArray(planeacion.elementosConfig)) {
                            planeacion.elementosConfig.forEach(componenteConfig => {
                                if (componenteConfig.elementos && Array.isArray(componenteConfig.elementos)) {
                                    componenteConfig.elementos.forEach(elemento => {
                                        if (elemento.elementoId) {
                                            elementosPlaneados.add(elemento.elementoId.toString());
                                        }
                                    });
                                }
                            });
                        }
                    });
                }
                
                window.elementosConPlaneacion = elementosPlaneados;
                console.log('‚úÖ Elementos con planeaci√≥n:', elementosPlaneados.size);
                resolve(elementosPlaneados);
            })
            .withFailureHandler(function() {
                window.elementosConPlaneacion = new Set();
                resolve(new Set());
            })
            .obtenerPlaneacionesPorProceso(currentUser ? currentUser.proceso : 'GENERAL');
    });
}

function toggleMenu(menuId) {
  const menu = document.getElementById(menuId);
  const arrow = document.getElementById(menuId + '-arrow');
  
  if (menu) menu.classList.toggle('hidden');
  if (arrow) arrow.classList.toggle('rotated');
}

function toggleSubmenu(submenuId) {
  const submenu = document.getElementById(submenuId);
  const arrow = document.getElementById('arrow-' + submenuId);
  
  if (submenu) submenu.classList.toggle('hidden');
  if (arrow) arrow.classList.toggle('rotated');
}

// ==================== TABS ====================
function switchTab(tabName) {
  // Si intenta acceder a planeaci√≥n y no es jefe, redirigir a avances
  if (tabName === 'planeacion' && currentUser.rol !== 'jefe') {
    showAlert("info", "Acceso restringido", "Solo los jefes pueden acceder a la planeaci√≥n");
    switchTab('avances');
    return;
  }
  
  document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
  document.getElementById('tab-' + tabName).classList.add('active');
  
  document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
  document.getElementById('content-' + tabName).classList.remove('hidden');
  
  if (tabName === 'avances') {
    loadEstadisticas();
  } else if (tabName === 'proceso') {
    loadProceso();
    loadPlaneaciones(); // Cargar planeaciones aqu√≠ tambi√©n
  } else if (tabName === 'planeacion') {
    // Solo cargar el √°rbol, no las planeaciones existentes
    renderMaquinasTree();
  }
}

function showMainView() {
  switchTab('planeacion');
}

// ==================== AVANCES (ESTAD√çSTICAS) ====================
function loadEstadisticas() {
  showLoading();
  
  google.script.run
    .withSuccessHandler(onEstadisticasLoaded)
    .withFailureHandler(function(error) {
      hideLoading();
      console.error('Error cargando estad√≠sticas:', error);
      renderEstadisticas([]);
    })
    .obtenerEstadisticasMaquinas();
}

function onEstadisticasLoaded(result) {
  hideLoading();
  
  if (result && result.success) {
    renderEstadisticas(result.estadisticas || []);
  } else {
    renderEstadisticas([]);
  }
}

function renderEstadisticas(estadisticas) {
  const container = document.getElementById('avances-grid');
  container.innerHTML = '';
  
  if (!estadisticas || estadisticas.length === 0) {
    container.innerHTML = '<p class="config-placeholder">No hay estad√≠sticas disponibles</p>';
    return;
  }
  
  estadisticas.forEach(stat => {
    const item = document.createElement('div');
    item.className = 'avance-item';
    item.innerHTML = `
      <div class="avance-header">
        <span class="avance-name">${stat.maquinaNombre}</span>
        <span class="avance-percentage">${stat.porcentaje} %</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" style="width: ${stat.porcentaje}%"></div>
      </div>
    `;
    container.appendChild(item);
  });
}

// ==================== PLANEACI√ìN - √ÅRBOL DE SELECCI√ìN ====================
function renderMaquinasTree() {
  const container = document.getElementById('maquinas-tree');
  container.innerHTML = '';
  
  if (!maquinasData || maquinasData.length === 0) {
    container.innerHTML = '<p class="config-placeholder">No hay m√°quinas disponibles</p>';
    return;
  }
  
  maquinasData.forEach(maquina => {
    const maquinaDiv = document.createElement('div');
    maquinaDiv.className = 'tree-maquina';
    
    const treeId = 'tree-maq-' + maquina.id;
    
    let componentesHtml = '';
    
    if (maquina.componentes && maquina.componentes.length > 0) {
      componentesHtml = maquina.componentes.map(componente => {
        const compTreeId = `tree-comp-${maquina.id}-${componente.id}`;
        
        const elementosHtml = (componente.elementos || []).map((elem) => `
          <div class="tree-elemento" id="tree-elem-${elem.id}">
            <input type="checkbox" id="check-elem-${elem.id}" 
              onclick="toggleElementoSelection('${maquina.id}', '${elem.id}', '${maquina.nombre}', '${elem.nombre}', '${componente.nombre}')">
            <span>${elem.nombre}</span>
          </div>
        `).join('');
        
        return `
          <div class="tree-componente">
            <div class="tree-componente-header" onclick="toggleTreeComponente('${compTreeId}', event)">
              <input type="checkbox" id="check-comp-${maquina.id}-${componente.id}" 
                onclick="event.stopPropagation(); toggleComponenteSelection('${maquina.id}', '${componente.id}')">
              <span>${componente.nombre}</span>
              <span class="tree-arrow" id="arrow-${compTreeId}">‚ñº</span>
            </div>
            <div id="${compTreeId}" class="tree-elementos hidden">
              ${elementosHtml}
            </div>
          </div>
        `;
      }).join('');
    }
    
    maquinaDiv.innerHTML = `
      <div class="tree-maquina-header" onclick="toggleTreeMaquina('${treeId}', event)">
        <input type="checkbox" id="check-maq-${maquina.id}" 
          onclick="event.stopPropagation(); toggleMaquinaSelection('${maquina.id}')">
        <span>${maquina.nombre}</span>
        <span class="tree-arrow" id="arrow-${treeId}">‚ñº</span>
      </div>
      <div id="${treeId}" class="tree-componentes hidden">
        ${componentesHtml}
      </div>
    `;
    container.appendChild(maquinaDiv);
  });
}

function toggleTreeComponente(compTreeId, event) {
  // Solo prevenir si el click fue directamente en el checkbox
  if (event && event.target.type === 'checkbox') {
    return;
  }
  
  // Reutilizar la l√≥gica existente
  const tree = document.getElementById(compTreeId);
  const arrow = document.getElementById('arrow-' + compTreeId);
  if (tree) tree.classList.toggle('hidden');
  if (arrow) arrow.classList.toggle('rotated');
}

function toggleComponenteSelection(maquinaId, componenteId) {
  const compCheck = document.getElementById('check-comp-' + maquinaId + '-' + componenteId);
  if (!compCheck) return;
  
  const isChecked = compCheck.checked;
  const maquina = maquinasData.find(m => m.id.toString() === maquinaId.toString());
  
  if (!maquina || !maquina.componentes) return;
  
  const componente = maquina.componentes.find(c => c.id.toString() === componenteId.toString());
  if (!componente || !componente.elementos) return;
  
  // Seleccionar/deseleccionar todos los elementos del componente
  componente.elementos.forEach(elem => {
    const elemCheck = document.getElementById('check-elem-' + elem.id);
    if (elemCheck) {
      elemCheck.checked = isChecked;
      if (isChecked) {
        addElementoToConfig(maquinaId, elem.id, maquina.nombre, elem.nombre, componente.nombre);
      } else {
        removeElementoFromConfig(elem.id);
      }
    }
  });
  
  // Actualizar estado de la m√°quina
  updateMaquinaCheckState(maquinaId);
  updateElementosConfigUI();
}

function toggleTreeMaquina(treeId, event) {
  // Solo prevenir si el click fue directamente en el checkbox
  if (event && event.target.type === 'checkbox') {
    return;
  }
  
  // Reutilizar la l√≥gica existente
  const tree = document.getElementById(treeId);
  const arrow = document.getElementById('arrow-' + treeId);
  if (tree) tree.classList.toggle('hidden');
  if (arrow) arrow.classList.toggle('rotated');
}

function toggleMaquinaSelection(maquinaId) {
  const maquinaCheck = document.getElementById('check-maq-' + maquinaId);
  if (!maquinaCheck) return;
  
  const isChecked = maquinaCheck.checked;
  const maquina = maquinasData.find(m => m.id.toString() === maquinaId.toString());
  
  if (!maquina || !maquina.componentes) return;
  
  // Seleccionar/deseleccionar todos los componentes y elementos
  maquina.componentes.forEach(componente => {
    const compCheck = document.getElementById('check-comp-' + maquinaId + '-' + componente.id);
    if (compCheck) {
      compCheck.checked = isChecked;
    }
    
    // Seleccionar/deseleccionar elementos del componente
    componente.elementos.forEach(elem => {
      const elemCheck = document.getElementById('check-elem-' + elem.id);
      if (elemCheck) {
        elemCheck.checked = isChecked;
        if (isChecked) {
          addElementoToConfig(maquinaId, elem.id, maquina.nombre, elem.nombre, componente.nombre);
        } else {
          removeElementoFromConfig(elem.id);
        }
      }
    });
  });
  
  updateElementosConfigUI();
}

function actualizarContadorSeleccionados() {
    const countElement = document.getElementById('selected-count');
    const actionItem = document.querySelector('.sidebar-action-item');
    
    if (countElement) {
        countElement.textContent = elementosSeleccionados.size;
        
        // Cambiar estilo seg√∫n cantidad de elementos
        if (elementosSeleccionados.size > 0) {
            countElement.style.backgroundColor = '#3b82f6';
            countElement.style.color = 'white';
            countElement.style.fontWeight = 'bold';
            
            // Resaltar el bot√≥n de limpieza masiva
            if (actionItem) {
                actionItem.style.backgroundColor = '#dbeafe';
                actionItem.style.borderColor = '#93c5fd';
                actionItem.style.fontWeight = '600';
            }
        } else {
            countElement.style.backgroundColor = '#9ca3af';
            countElement.style.color = '#f9fafb';
            countElement.style.fontWeight = 'normal';
            
            // Restaurar estilo normal del bot√≥n
            if (actionItem) {
                actionItem.style.backgroundColor = '';
                actionItem.style.borderColor = '';
                actionItem.style.fontWeight = '';
            }
        }
    }
}

function updateComponenteCheckState(maquinaId, componenteId) {
  const maquina = maquinasData.find(m => m.id.toString() === maquinaId.toString());
  if (!maquina || !maquina.componentes) return;
  
  const componente = maquina.componentes.find(c => c.id.toString() === componenteId.toString());
  if (!componente || !componente.elementos) return;
  
  const compCheck = document.getElementById('check-comp-' + maquinaId + '-' + componenteId);
  if (!compCheck) return;
  
  const allChecked = componente.elementos.every(elem => {
    const check = document.getElementById('check-elem-' + elem.id);
    return check && check.checked;
  });
  
  const someChecked = componente.elementos.some(elem => {
    const check = document.getElementById('check-elem-' + elem.id);
    return check && check.checked;
  });
  
  compCheck.checked = allChecked;
  compCheck.indeterminate = someChecked && !allChecked;
}

function addElementoToConfig(maquinaId, elementoId, maquinaNombre, elementoNombre, componenteNombre) {
  selectedElementosConfig[elementoId] = {
    maquinaId: maquinaId,
    elementoId: elementoId,
    maquinaNombre: maquinaNombre,
    elementoNombre: elementoNombre,
    componenteNombre: componenteNombre || 'Componente PRINCIPAL',
    seco: true,
    humedo: true,
    desinfeccion: true
  };
  
  const treeElem = document.getElementById('tree-elem-' + elementoId);
  if (treeElem) treeElem.classList.add('selected');
}

function removeElementoFromConfig(elementoId) {
  delete selectedElementosConfig[elementoId];
  
  const treeElem = document.getElementById('tree-elem-' + elementoId);
  if (treeElem) treeElem.classList.remove('selected');
}

function updateMaquinaCheckState(maquinaId) {
  const maquina = maquinasData.find(m => m.id.toString() === maquinaId.toString());
  if (!maquina || !maquina.componentes) return;
  
  const maquinaCheck = document.getElementById('check-maq-' + maquinaId);
  if (!maquinaCheck) return;
  
  const allChecked = maquina.componentes.every(componente => {
    const compCheck = document.getElementById('check-comp-' + maquinaId + '-' + componente.id);
    return compCheck && compCheck.checked;
  });
  
  const someChecked = maquina.componentes.some(componente => {
    const compCheck = document.getElementById('check-comp-' + maquinaId + '-' + componente.id);
    return compCheck && compCheck.checked;
  });
  
  maquinaCheck.checked = allChecked;
  maquinaCheck.indeterminate = someChecked && !allChecked;
}


function updateElementosConfigUI() {
  const container = document.getElementById('elementos-config-list');
  const elementos = Object.values(selectedElementosConfig);
  
  if (elementos.length === 0) {
    container.innerHTML = '<p class="config-placeholder">Seleccione elementos del √°rbol para configurar sus tipos de limpieza</p>';
    return;
  }
  
  container.innerHTML = elementos.map(elem => `
    <div class="elemento-config-item">
      <div class="elemento-config-name">${elem.maquinaNombre} - ${elem.componenteNombre} - ${elem.elementoNombre}</div>
      <div class="checkbox-group">
        <label class="checkbox-item">
          <input type="checkbox" id="cfg-seco-${elem.elementoId}" ${elem.seco ? 'checked' : ''} onchange="updateElementoConfig('${elem.elementoId}', 'seco', this.checked)">
          Limpieza Seco
        </label>
        <label class="checkbox-item">
          <input type="checkbox" id="cfg-humedo-${elem.elementoId}" ${elem.humedo ? 'checked' : ''} onchange="updateElementoConfig('${elem.elementoId}', 'humedo', this.checked)">
          Limpieza H√∫medo
        </label>
        <label class="checkbox-item">
          <input type="checkbox" id="cfg-desinfeccion-${elem.elementoId}" ${elem.desinfeccion ? 'checked' : ''} onchange="updateElementoConfig('${elem.elementoId}', 'desinfeccion', this.checked)">
          Desinfecci√≥n
        </label>
      </div>
    </div>
  `).join('');
}

function updateElementosConfigUI() {
  const container = document.getElementById('elementos-config-list');
  const elementos = Object.values(selectedElementosConfig);
  
  if (elementos.length === 0) {
    container.innerHTML = '<p class="config-placeholder">Seleccione elementos del √°rbol para configurar sus tipos de limpieza</p>';
    return;
  }
  
  // AGREGAR SELECTOR DE RESPONSABLE GENERAL (antes de la lista)
  container.innerHTML = `
    <div class="config-responsable-general">
      <label class="form-label">Responsable general para todos los elementos:</label>
      <select id="responsable-general" class="input-field" onchange="actualizarResponsableGeneral()">
        <option value="OPERARIO">Operario</option>
        <option value="CONTRATISTA">Contratista</option>
      </select>
      <small class="form-hint">Puede cambiar individualmente cada elemento despu√©s</small>
    </div>
  `;
  
  // Luego agregar la lista de elementos
  elementos.forEach(elem => {
    container.innerHTML += `
      <div class="elemento-config-item">
        <div class="elemento-config-name">${elem.maquinaNombre} - ${elem.componenteNombre} - ${elem.elementoNombre}</div>
        <div class="checkbox-group">
          <label class="checkbox-item">
            <input type="checkbox" id="cfg-seco-${elem.elementoId}" ${elem.seco ? 'checked' : ''} onchange="updateElementoConfig('${elem.elementoId}', 'seco', this.checked)">
            Limpieza Seco
          </label>
          <label class="checkbox-item">
            <input type="checkbox" id="cfg-humedo-${elem.elementoId}" ${elem.humedo ? 'checked' : ''} onchange="updateElementoConfig('${elem.elementoId}', 'humedo', this.checked)">
            Limpieza H√∫medo
          </label>
          <label class="checkbox-item">
            <input type="checkbox" id="cfg-desinfeccion-${elem.elementoId}" ${elem.desinfeccion ? 'checked' : ''} onchange="updateElementoConfig('${elem.elementoId}', 'desinfeccion', this.checked)">
            Desinfecci√≥n
          </label>
        </div>
        <!-- NUEVO: Selector de responsable individual -->
        <div class="responsable-selector">
          <label class="form-label">Responsable:</label>
          <select id="resp-${elem.elementoId}" class="input-field small" onchange="updateElementoConfig('${elem.elementoId}', 'responsable', this.value)">
            <option value="OPERARIO" ${elem.responsable === 'OPERARIO' || !elem.responsable ? 'selected' : ''}>Operario</option>
            <option value="CONTRATISTA" ${elem.responsable === 'CONTRATISTA' ? 'selected' : ''}>Contratista</option>
          </select>
        </div>
      </div>
    `;
  });
}

// Nueva funci√≥n para actualizar responsable general
function actualizarResponsableGeneral() {
  const responsableGeneral = document.getElementById('responsable-general').value;
  const elementos = Object.values(selectedElementosConfig);
  
  elementos.forEach(elem => {
    selectedElementosConfig[elem.elementoId].responsable = responsableGeneral;
    // Actualizar el select individual
    const selectIndividual = document.getElementById('resp-' + elem.elementoId);
    if (selectIndividual) {
      selectIndividual.value = responsableGeneral;
    }
  });
}

// Modificar updateElementoConfig para incluir responsable
function updateElementoConfig(elementoId, tipo, value) {
  if (selectedElementosConfig[elementoId]) {
    selectedElementosConfig[elementoId][tipo] = value;
  }
}

function guardarPlaneacion() {
  const elementos = Object.values(selectedElementosConfig);
  
  if (elementos.length === 0) {
    showAlert("info", "¬°Upss!", "Por favor seleccione al menos un elemento para planear"); 
    return;
  }
  
  const sinTipos = elementos.filter(e => !e.seco && !e.humedo && !e.desinfeccion);
  if (sinTipos.length > 0) {
    showAlert("info", "¬°Upss!", "Cada elemento debe tener al menos un tipo de limpieza seleccionado");
    return;
  }
  
  const frecuencia = document.getElementById('select-frecuencia').value;
  const responsableGeneral = document.getElementById('responsable-general') ? 
                           document.getElementById('responsable-general').value : 'OPERARIO';
  
  console.log('üíæ Guardando planeaci√≥n con responsable:', responsableGeneral);
  
  // Agrupar por m√°quina y componente
  const maquinasAgrupadas = {};
  
  elementos.forEach(elem => {
    const maquinaKey = elem.maquinaId;
    
    if (!maquinasAgrupadas[maquinaKey]) {
      maquinasAgrupadas[maquinaKey] = {
        maquinaId: elem.maquinaId,
        maquinaNombre: elem.maquinaNombre,
        componentes: {}
      };
    }
    
    const componenteKey = elem.componenteNombre || 'Componente PRINCIPAL';
    
    if (!maquinasAgrupadas[maquinaKey].componentes[componenteKey]) {
      maquinasAgrupadas[maquinaKey].componentes[componenteKey] = {
        nombre: componenteKey,
        elementos: []
      };
    }
    
    // AGREGAR RESPONSABLE AL ELEMENTO
    maquinasAgrupadas[maquinaKey].componentes[componenteKey].elementos.push({
      elementoId: elem.elementoId,
      elementoNombre: elem.elementoNombre,
      seco: elem.seco,
      humedo: elem.humedo,
      desinfeccion: elem.desinfeccion,
      responsable: elem.responsable || responsableGeneral // ‚Üê AQU√ç
    });
  });
  
  showLoading();
  
  const maquinas = Object.values(maquinasAgrupadas);
  let saved = 0;
  let errors = [];
  
  maquinas.forEach(maq => {
    // Preparar datos para guardar
    const elementosConfig = [];
    const componentes = Object.values(maq.componentes);
    
    componentes.forEach(comp => {
      elementosConfig.push({
        componenteNombre: comp.nombre,
        elementos: comp.elementos
      });
    });
    
    const datos = {
      maquinaId: maq.maquinaId,
      maquinaNombre: maq.maquinaNombre,
      frecuencia: frecuencia,
      limpiezaSeco: componentes.some(comp => comp.elementos.some(e => e.seco)),
      limpiezaHumedo: componentes.some(comp => comp.elementos.some(e => e.humedo)),
      desinfeccion: componentes.some(comp => comp.elementos.some(e => e.desinfeccion)),
      elementosConfig: elementosConfig, // Ahora incluye responsable
      componentes: componentes,
      usuarioCreador: currentUser ? currentUser.nombre : 'Sistema',
      responsable: responsableGeneral // ‚Üê A√ëADIR RESPONSABLE GENERAL
    };
    
    console.log('üì§ Enviando datos con responsable:', datos);
    
    google.script.run
      .withSuccessHandler(function(result) {
        saved++;
        console.log('üì• Respuesta guardar planeaci√≥n:', result);
        
        if (result && !result.success) {
          errors.push(result.message || 'Error desconocido');
        }
        
        if (saved === maquinas.length) {
          hideLoading();
          if (errors.length === 0) {
            showAlert("success", "¬°√âxito!", "Planeaci√≥n guardada correctamente");
            selectedElementosConfig = {};
            renderMaquinasTree();
            updateElementosConfigUI();
            loadPlaneaciones();
            actualizarEstadosSidebar();
          } else {
            showAlert('error', 'Error', 'Algunos errores ocurrieron ' + errors.join(', '));
          }
        }
      })
      .withFailureHandler(function(error) {
        saved++;
        errors.push(error.message || 'Error desconocido');
        console.error('‚ùå Error guardando planeaci√≥n:', error);
        if (saved === maquinas.length) {
          hideLoading();
          showAlert('error', 'Error', 'Error al guardar ' + errors.join(', '));
        }
      })
      .guardarPlaneacion(datos);
  });
}

function loadPlaneaciones() {
  console.log('üîÑ Cargando planeaciones...');
  showLoading();
  
  // Si es GEN, obtener todas, si no, por proceso
  if (currentUser.proceso === 'GENERAL') {
    google.script.run
      .withSuccessHandler(onPlaneacionesLoaded)
      .withFailureHandler(function(error) {
        hideLoading();
        console.error('‚ùå Error cargando planeaciones:', error);
        renderPlaneaciones([]);
      })
      .obtenerTodasLasPlaneaciones();
  } else {
    google.script.run
      .withSuccessHandler(onPlaneacionesLoaded)
      .withFailureHandler(function(error) {
        hideLoading();
        console.error('‚ùå Error cargando planeaciones:', error);
        renderPlaneaciones([]);
      })
      .obtenerPlaneacionesPorProceso(currentUser.proceso);
  }
}

function onPlaneacionesLoaded(result) {
  hideLoading();
  console.log('üì• Respuesta de planeaciones:', result);
  
  if (!result) {
    console.error('‚ùå Error: Respuesta nula de planeaciones');
    showError('planeacion-error', 'Error: No se recibi√≥ respuesta del servidor');
    renderPlaneaciones([]);
    return;
  }
  
  if (result.success) {
    hideError('planeacion-error');
    console.log('‚úÖ Planeaciones cargadas:', result.planeaciones ? result.planeaciones.length : 0);
    renderPlaneaciones(result.planeaciones || []);
  } else {
    console.error('‚ùå Error en planeaciones:', result.message);
    showError('planeacion-error', result.message || 'Error desconocido al cargar planeaciones');
    renderPlaneaciones([]);
  }
}

async function renderPlaneaciones(planeaciones) {
  const container = document.getElementById('planeaciones-grid');
  container.innerHTML = '';
  
  if (!planeaciones || planeaciones.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <p class="config-placeholder">No hay planeaciones registradas</p>
        ${currentUser.rol === 'jefe' ? 
          `<button onclick="switchTab('planeacion')" class="btn-principal" style="margin-top: 16px;">
            Crear primera planeaci√≥n
          </button>` : ''
        }
      </div>
    `;
    return;
  }
  
  // Procesar datos para obtener estados de limpieza
  const maquinasDetalladas = await procesarMaquinasConEstados(planeaciones);
  
  let html = `
    <div class="consolidado-detallado">
      <div class="consolidado-header">
        <h3 class="header-title">Consolidado Detallado de Limpiezas</h3>
        <div class="header-stats">
          <span class="stat-item">
            <i class="fas fa-industry"></i> ${maquinasDetalladas.length} M√°quinas
          </span>
          <span class="stat-item">
            <i class="fas fa-layer-group"></i> ${calcularTotalComponentes(maquinasDetalladas)} Componentes
          </span>
          <span class="stat-item">
            <i class="fas fa-list"></i> ${calcularTotalElementos(maquinasDetalladas)} Elementos
          </span>
        </div>
      </div>
  `;
  
  // Para cada m√°quina
  maquinasDetalladas.forEach(maquina => {
    const esJefe = currentUser.rol === 'jefe';
    
    html += `
  <div class="maquina-detallada" data-maquina-id="${maquina.maquinaId}">
    <!-- ENCABEZADO DE M√ÅQUINA -->
    <div class="maquina-header">
      <div class="maquina-info">
        <div class="maquina-titulo">
          <h4>${maquina.maquinaNombre}</h4>
          <span class="maquina-meta">
            <span class="badge estado ${maquina.estadoGeneral.toLowerCase()}">${maquina.estadoGeneral}</span>
            <span class="meta-info">ID: ${maquina.maquinaId} | Proceso: ${maquina.proceso || 'GENERAL'}</span>
          </span>
          
          <!-- NUEVO: Selector de frecuencia simple -->
          <div style="margin-top: 8px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
            <span style="font-size: 12px; color: #6b7280;">
              Frecuencia actual: 
              <span style="color: #374151; font-weight: 500;">${maquina.frecuencia || 'Mensual'}</span>
            </span>
            
            ${currentUser.rol === 'jefe' ? `
              <select class="input-field small" 
                      id="frecuencia-${maquina.maquinaId}" 
                      style="width: 120px; font-size: 11px; padding: 3px 6px;"
                      onchange="cambiarFrecuenciaIndividual('${maquina.maquinaId}', '${maquina.maquinaNombre}', this.value)">
                <option value="Mensual" ${maquina.frecuencia === 'Mensual' ? 'selected' : ''}>Mensual</option>
                <option value="Trimestral" ${maquina.frecuencia === 'Trimestral' ? 'selected' : ''}>Trimestral</option>
                <option value="Semestral" ${maquina.frecuencia === 'Semestral' ? 'selected' : ''}>Semestral</option>
                <option value="Anual" ${maquina.frecuencia === 'Anual' ? 'selected' : ''}>Anual</option>
              </select>
              <button class="btn-save-frecuencia" 
                      onclick="guardarFrecuencia('${maquina.maquinaId}', '${maquina.maquinaNombre}')"
                      style="padding: 3px 8px; font-size: 11px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;">
                <i class="fas fa-save"></i> Guardar
              </button>
            ` : ''}
          </div>
        </div>
        <div class="maquina-creador">
          <i class="fas fa-user"></i> ${maquina.usuarioCreador}
          <span class="fecha">${formatFechaSimple(maquina.fechaCreacion)}</span>
        </div>
      </div>
      <div class="maquina-acciones">
            <!-- Bot√≥n de validaci√≥n (solo para jefes) -->
            ${esJefe && maquina.estadoGeneral === 'COMPLETADO' && maquina.maquinaId ? `
              <button class="btn-validar-maquina" 
                      onclick="validarMaquinaCompleta('${maquina.maquinaId || ''}', '${maquina.maquinaNombre || ''}')" 
                      title="Validar limpieza completa">
                <i class="fa-jelly fa-regular fa-thumbs-up"></i> Validar
              </button>
            ` : ''}
            
            <!-- Bot√≥n de eliminaci√≥n (solo para jefes) -->
            ${esJefe ? `
              <button class="btn-eliminar-maquina" 
                      onclick="eliminarPlaneacionMaquina('${maquina.maquinaId}', '${maquina.maquinaNombre}')" 
                      title="Eliminar m√°quina">
                <i class="fas fa-trash"></i>
              </button>
            ` : ''}

            ${maquina.estadoGeneral === 'VALIDADO' ? `
              <button class="btn-reporte-maquina" 
                      onclick="generarReporteMaquina('${maquina.maquinaId}', '${maquina.maquinaNombre}')" 
                      title="Generar reporte PDF">
                <i class="fas fa-file-pdf"></i> Reporte
              </button>
            ` : ''}
          </div>
        </div>
        
        <!-- RESUMEN DE ESTADOS -->
        <div class="estados-resumen">
          <div class="estado-item">
            <div class="estado-icono completado">
              <i class="fas fa-check-circle"></i>
            </div>
            <div class="estado-info">
              <div class="estado-cantidad">${maquina.estadisticas.completados}</div>
              <div class="estado-label">Completados</div>
            </div>
          </div>
          <div class="estado-item">
            <div class="estado-icono en-proceso">
              <i class="fas fa-spinner"></i>
            </div>
            <div class="estado-info">
              <div class="estado-cantidad">${maquina.estadisticas.enProceso}</div>
              <div class="estado-label">En proceso</div>
            </div>
          </div>
          <div class="estado-item">
            <div class="estado-icono pendiente">
              <i class="fas fa-clock"></i>
            </div>
            <div class="estado-info">
              <div class="estado-cantidad">${maquina.estadisticas.pendientes}</div>
              <div class="estado-label">Pendientes</div>
            </div>
          </div>
          <div class="estado-item">
            <div class="estado-icono validado">
              <i class="fa-jelly fa-regular fa-thumbs-up"></i>
            </div>
            <div class="estado-info">
              <div class="estado-cantidad">${maquina.estadisticas.validados}</div>
              <div class="estado-label">Validados</div>
            </div>
          </div>
        </div>

        <!-- INFORMACI√ìN DE VALIDACI√ìN -->
        <div class="validacion-resumen" id="validacion-info-${maquina.maquinaId}" 
             style="${maquina.estadoGeneral === 'VALIDADO' ? '' : 'display: none;'}">
          <div class="validacion-header">
            <i class="fa-jelly fa-regular fa-thumbs-up" style="color: #10b981;"></i>
            <span style="font-weight: 600; color: #065f46;">LIMPIEZA VALIDADA</span>
          </div>
          <div class="validacion-detalles">
            <span id="validador-${maquina.maquinaId}"></span>
            <span id="fecha-validacion-${maquina.maquinaId}"></span>
          </div>
        </div>
    `;
    
    // Para cada componente
    maquina.componentes.forEach(componente => {
      html += `
        <div class="componente-detallado">
          <!-- ENCABEZADO DE COMPONENTE -->
          <div class="componente-header">
            <div class="componente-titulo">
              <h5>${componente.nombre}</h5>
              <span class="componente-estado ${componente.estado.toLowerCase()}">
                ${componente.elementosCompletados}/${componente.totalElementos} elementos
              </span>
            </div>
            <div class="componente-tipos">
      `;
      
      // Mostrar tipos de limpieza del componente
      if (componente.tiposLimpieza && componente.tiposLimpieza.length > 0) {
        componente.tiposLimpieza.forEach(tipo => {
          html += `<span class="tipo-badge ${tipo.toLowerCase()}">${tipo}</span>`;
        });
      }
      
      html += `
            </div>
          </div>
          
          <!-- TABLA DE ELEMENTOS -->
          <div class="elementos-table-container">
             <table class="elementos-table">
    <thead>
      <tr>
        <th class="col-elemento">Elemento</th>
        <th class="col-frecuencia">Frecuencia</th> <!-- NUEVA COLUMNA -->
        <th class="col-tipos">Tipos de Limpieza</th>
        <th class="col-estado">Estado</th>
        <th class="col-proxima">Pr√≥xima Limpieza</th> <!-- NUEVA COLUMNA -->
        <th class="col-responsable">Responsable</th>
        <th class="col-fecha">Fecha</th>
        <th class="col-validacion">Validaci√≥n</th>
      </tr>
    </thead>
    <tbody>
`;
      
      // Para cada elemento
      componente.elementos.forEach(elemento => {
  // Clase CSS seg√∫n estado de pr√≥xima limpieza
  const estadoProximaClass = elemento.estadoProxima || 'normal';
  
  html += `
    <tr class="elemento-fila ${elemento.estado.toLowerCase()}">
      <td class="col-elemento">
        <div class="elemento-nombre">${elemento.nombre}</div>
      </td>
      
      <td class="col-frecuencia">
        <div class="elemento-frecuencia">
          <span class="frecuencia-badge ${elemento.frecuencia.toLowerCase()}">
            ${elemento.frecuencia}
          </span>
        </div>
      </td>
      
      <td class="col-tipos">
        <div class="elemento-tipos">
  `;
  
  // Mostrar tipos de limpieza del elemento
  if (elemento.seco) html += '<span class="tipo-item seco">Seco</span>';
  if (elemento.humedo) html += '<span class="tipo-item humedo">H√∫medo</span>';
  if (elemento.desinfeccion) html += '<span class="tipo-item desinfeccion">Desinfecci√≥n</span>';
  
  html += `
        </div>
      </td>
      
      <td class="col-estado">
        <span class="estado-elemento ${elemento.estado.toLowerCase()}">
          ${obtenerIconoEstado(elemento.estado)} ${elemento.estado}
        </span>
      </td>
      
      <td class="col-proxima">
        <div class="proxima-info ${estadoProximaClass}">
          <div class="proxima-dias">${elemento.diasFaltantes} d√≠as</div>
          <div class="proxima-fecha">${elemento.proximaFecha || 'No disponible'}</div>
        </div>
      </td>
      
      <td class="col-responsable">
  `;
  
  if (elemento.responsables && elemento.responsables.length > 0) {
    elemento.responsables.forEach((responsable, index) => {
      if (index < 2) {
        html += `<div class="responsable-item">${responsable}</div>`;
      }
    });
    if (elemento.responsables.length > 2) {
      html += `<div class="responsable-more">+${elemento.responsables.length - 2} m√°s</div>`;
    }
  } else {
    html += '<span class="text-muted">Sin asignar</span>';
  }
  
  html += `
      </td>
      
      <td class="col-fecha">
  `;
  
  if (elemento.ultimaLimpieza) {
    html += `<div class="fecha-limpieza">${formatFechaSimple(elemento.ultimaLimpieza)}</div>`;
  } else {
    html += '<span class="text-muted">No realizada</span>';
  }
  
  html += `
      </td>
      
      <td class="col-validacion">
  `;
  
  if (elemento.validadoPor) {
    html += `
      <div class="validacion-info">
        <div class="validador">${elemento.validadoPor}</div>
        <div class="fecha-validacion">${formatFechaSimple(elemento.fechaValidacion)}</div>
      </div>
    `;
  } else {
    html += '<span class="text-muted">Pendiente</span>';
  }
  
  html += `
      </td>
    </tr>
  `;
});
      
      html += `
              </tbody>
            </table>
          </div>
        </div>
      `;
    });
    
    html += `</div>`; // Cierre de maquina-detallada
  });
  
  html += `</div>`; // Cierre de consolidado-detallado
  
  container.innerHTML = html;
}

// Funci√≥n para procesar m√°quinas con estados
async function procesarMaquinasConEstados(planeaciones) {
  // Primero, obtener todos los registros de limpieza para calcular estados
  const registrosLimpieza = await obtenerTodosRegistrosLimpieza();
  
  const maquinasMap = new Map();
  
  // Procesar cada planeaci√≥n
  planeaciones.forEach(plan => {
    const maquinaId = plan.maquinaId;
    
    if (!maquinasMap.has(maquinaId)) {
      maquinasMap.set(maquinaId, {
        maquinaId: maquinaId,
        maquinaNombre: plan.maquinaNombre || 'Sin nombre',
        frecuencia: plan.frecuencia,
        usuarioCreador: plan.usuarioCreador || 'Sistema',
        fechaCreacion: plan.fechaCreacion,
        estadoGeneral: plan.estado || 'ACTIVA',
        proceso: plan.procesoAsignado || 'GENERAL',
        componentes: [],
        estadisticas: {
          total: 0,
          completados: 0,
          enProceso: 0,
          pendientes: 0,
          validados: 0
        }
      });
    }
    
    const maquina = maquinasMap.get(maquinaId);
    
    // Procesar componentes y elementos
    if (plan.elementosConfig && Array.isArray(plan.elementosConfig)) {
      plan.elementosConfig.forEach(componenteConfig => {
        const componenteNombre = componenteConfig.componenteNombre || 'Componente PRINCIPAL';
        
        let componente = maquina.componentes.find(c => c.nombre === componenteNombre);
        if (!componente) {
          componente = {
            nombre: componenteNombre,
            elementos: [],
            totalElementos: 0,
            elementosCompletados: 0,
            elementosValidados: 0,
            estado: 'pendiente',
            tiposLimpieza: []
          };
          maquina.componentes.push(componente);
        }
        
        // Procesar elementos del componente
        if (componenteConfig.elementos && Array.isArray(componenteConfig.elementos)) {
          componenteConfig.elementos.forEach(elementoConfig => {
            const elementoId = elementoConfig.elementoId;
            const elementoNombre = elementoConfig.elementoNombre || 'Elemento';
            
            // Buscar registros de limpieza para este elemento
            const registrosElemento = registrosLimpieza.filter(r => 
              r.elementoId === elementoId && r.maquinaId === maquinaId
            );
            
            // Calcular estado del elemento
            const estadoElemento = calcularEstadoElemento(registrosElemento);
            
            // Obtener frecuencia espec√≠fica para este elemento
            const frecuenciaElemento = plan.frecuencia || 'Mensual';
            
            // Calcular d√≠as faltantes para pr√≥xima limpieza
            const infoProximaLimpieza = calcularProximaLimpiezaElemento(
              registrosElemento, 
              frecuenciaElemento
            );
            
            // Extraer responsables y fechas
            const responsables = [];
            let ultimaLimpieza = null;
            let validadoPor = null;
            let fechaValidacion = null;
            
            registrosElemento.forEach(registro => {
              if (registro.responsable && !responsables.includes(registro.responsable)) {
                responsables.push(registro.responsable);
              }
              if (registro.fechaRealizacion) {
                ultimaLimpieza = registro.fechaRealizacion;
              }
              if (registro.validadoPor) {
                validadoPor = registro.validadoPor;
                fechaValidacion = registro.fechaValidacion;
              }
            });
            
            const elemento = {
              id: elementoId,
              nombre: elementoNombre,
              seco: elementoConfig.seco,
              humedo: elementoConfig.humedo,
              desinfeccion: elementoConfig.desinfeccion,
              frecuencia: frecuenciaElemento, // ‚Üê NUEVO: Frecuencia espec√≠fica
              estado: estadoElemento,
              responsables: responsables,
              ultimaLimpieza: ultimaLimpieza,
              validadoPor: validadoPor,
              fechaValidacion: fechaValidacion,
              diasFaltantes: infoProximaLimpieza.diasFaltantes, // ‚Üê NUEVO: D√≠as faltantes
              proximaFecha: infoProximaLimpieza.proximaFecha, // ‚Üê NUEVO: Pr√≥xima fecha
              estadoProxima: infoProximaLimpieza.estado // ‚Üê NUEVO: Estado de pr√≥xima limpieza
            };
            
            componente.elementos.push(elemento);
            componente.totalElementos++;
            
            // Actualizar estad√≠sticas del componente
            if (estadoElemento === 'COMPLETADO' || estadoElemento === 'VALIDADO') {
              componente.elementosCompletados++;
            }
            if (estadoElemento === 'VALIDADO') {
              componente.elementosValidados++;
            }
            
            // Actualizar tipos de limpieza del componente
            if (elementoConfig.seco && !componente.tiposLimpieza.includes('SECO')) {
              componente.tiposLimpieza.push('SECO');
            }
            if (elementoConfig.humedo && !componente.tiposLimpieza.includes('HUMEDO')) {
              componente.tiposLimpieza.push('HUMEDO');
            }
            if (elementoConfig.desinfeccion && !componente.tiposLimpieza.includes('DESINFECCION')) {
              componente.tiposLimpieza.push('DESINFECCION');
            }
            
            // Actualizar estad√≠sticas de la m√°quina
            maquina.estadisticas.total++;
            switch(estadoElemento) {
              case 'COMPLETADO':
                maquina.estadisticas.completados++;
                break;
              case 'EN-PROCESO':
                maquina.estadisticas.enProceso++;
                break;
              case 'PENDIENTE':
                maquina.estadisticas.pendientes++;
                break;
              case 'VALIDADO':
                maquina.estadisticas.validados++;
                break;
            }
          });
        }
        
        // Determinar estado del componente
        if (componente.elementosValidados === componente.totalElementos && componente.totalElementos > 0) {
          componente.estado = 'VALIDADO';
        } else if (componente.elementosCompletados === componente.totalElementos && componente.totalElementos > 0) {
          componente.estado = 'COMPLETADO';
        } else if (componente.elementosCompletados > 0) {
          componente.estado = 'EN-PROCESO';
        } else {
          componente.estado = 'PENDIENTE';
        }
      });
    }
  });
  
  // Determinar estado general de cada m√°quina
  maquinasMap.forEach(maquina => {
    if (maquina.estadisticas.validados === maquina.estadisticas.total && maquina.estadisticas.total > 0) {
      maquina.estadoGeneral = 'VALIDADO';
    } else if (maquina.estadisticas.completados === maquina.estadisticas.total && maquina.estadisticas.total > 0) {
      maquina.estadoGeneral = 'COMPLETADO';
    } else if (maquina.estadisticas.completados > 0 || maquina.estadisticas.enProceso > 0) {
      maquina.estadoGeneral = 'EN-PROCESO';
    } else {
      maquina.estadoGeneral = 'PENDIENTE';
    }
  });
  
  return Array.from(maquinasMap.values()).sort((a, b) => a.maquinaNombre.localeCompare(b.maquinaNombre));
}

// Funci√≥n para calcular pr√≥xima limpieza de un elemento
function calcularProximaLimpiezaElemento(registrosElemento, frecuencia) {
  if (!registrosElemento || registrosElemento.length === 0) {
    return {
      diasFaltantes: 0,
      proximaFecha: 'Inmediatamente',
      estado: 'urgente',
      texto: 'No se ha limpiado nunca'
    };
  }
  
  // Encontrar la √∫ltima fecha de limpieza completada
  const limpiezasCompletadas = registrosElemento.filter(r => 
    r.estado === 'COMPLETADO' || r.estado === 'VALIDADO'
  );
  
  if (limpiezasCompletadas.length === 0) {
    return {
      diasFaltantes: 0,
      proximaFecha: 'Inmediatamente',
      estado: 'urgente',
      texto: 'Pendiente de limpieza'
    };
  }
  
  // Ordenar por fecha m√°s reciente
  limpiezasCompletadas.sort((a, b) => {
    const fechaA = a.fechaRealizacion ? new Date(a.fechaRealizacion) : new Date(0);
    const fechaB = b.fechaRealizacion ? new Date(b.fechaRealizacion) : new Date(0);
    return fechaB - fechaA;
  });
  
  // Usar una funci√≥n segura para obtener la fecha sin problemas de zona horaria
  const ultimaLimpieza = obtenerFechaSinZonaHoraria(limpiezasCompletadas[0].fechaRealizacion);
  
  // Calcular d√≠as seg√∫n frecuencia
  let diasFrecuencia;
  switch(frecuencia.toLowerCase()) {
    case 'mensual':
      diasFrecuencia = 30;
      break;
    case 'trimestral':
      diasFrecuencia = 90;
      break;
    case 'semestral':
      diasFrecuencia = 180;
      break;
    case 'anual':
      diasFrecuencia = 365;
      break;
    case 'diario':
      diasFrecuencia = 1;
      break;
    case 'semanal':
      diasFrecuencia = 7;
      break;
    default:
      diasFrecuencia = 30; // Por defecto mensual
  }
  
  // Calcular pr√≥xima fecha (sumar d√≠as sin problemas de zona horaria)
  const proximaFecha = new Date(ultimaLimpieza);
  proximaFecha.setDate(proximaFecha.getDate() + diasFrecuencia);
  
  // Obtener fecha de hoy sin hora (medianoche UTC)
  const hoy = obtenerHoySinHora();
  
  // Calcular d√≠as faltantes correctamente
  const diasFaltantes = Math.ceil((proximaFecha - hoy) / (1000 * 60 * 60 * 24));
  
  let estado = 'normal';
  let texto = '';
  
  if (diasFaltantes <= 0) {
    estado = 'vencido';
    texto = `¬°Vencido hace ${Math.abs(diasFaltantes)} d√≠as!`;
  } else if (diasFaltantes <= 7) {
    estado = 'proximo';
    texto = `En ${diasFaltantes} d√≠as`;
  } else {
    estado = 'normal';
    texto = `En ${diasFaltantes} d√≠as`;
  }
  
  // Formatear fecha de pr√≥xima limpieza (sin problemas de zona horaria)
  const proximaFechaFormateada = formatearFechaLocal(proximaFecha);
  
  return {
    diasFaltantes: diasFaltantes,
    proximaFecha: proximaFechaFormateada,
    estado: estado,
    texto: texto
  };
}

// Funci√≥n auxiliar para obtener fecha sin problemas de zona horaria
function obtenerFechaSinZonaHoraria(fechaString) {
  if (!fechaString) return new Date();
  
  // Si la fecha ya es un objeto Date, devolver copia
  if (fechaString instanceof Date) {
    return new Date(fechaString.getTime());
  }
  
  // Si es string, parsear correctamente
  const fecha = new Date(fechaString);
  
  // Crear nueva fecha ajustando la zona horaria
  const fechaAjustada = new Date(
    fecha.getUTCFullYear(),
    fecha.getUTCMonth(),
    fecha.getUTCDate(),
    12, 0, 0 // Poner a mediod√≠a para evitar problemas de zona horaria
  );
  
  return fechaAjustada;
}

// Funci√≥n para obtener la fecha de hoy sin hora (medianoche local)
function obtenerHoySinHora() {
  const hoy = new Date();
  // Establecer a medianoche en hora local
  return new Date(hoy.getFullYear(), hoy.getMonth(), hoy.getDate());
}

// Funci√≥n para formatear fecha en formato local sin problemas
function formatearFechaLocal(fecha) {
  if (!fecha) return '';
  
  // Asegurarse de que es un objeto Date
  const fechaObj = fecha instanceof Date ? fecha : new Date(fecha);
  
  // Formatear en espa√±ol
  return fechaObj.toLocaleDateString('es-ES', {
    day: '2-digit',
    month: '2-digit', 
    year: 'numeric',
    timeZone: 'UTC' // Usar UTC para evitar desplazamientos
  });
}

// Funci√≥n para obtener todos los registros de limpieza
function obtenerTodosRegistrosLimpieza() {
  return new Promise((resolve) => {
    google.script.run
      .withSuccessHandler(function(result) {
        if (result && result.success) {
          resolve(result.registros || []);
        } else {
          resolve([]);
        }
      })
      .withFailureHandler(function() {
        resolve([]);
      })
      .obtenerTodosRegistrosLimpieza(); // ¬°CAMBIA AQU√ç!
  });
}

// Funci√≥n para calcular estado de un elemento
function calcularEstadoElemento(registros) {
  if (!registros || registros.length === 0) {
    return 'PENDIENTE';
  }
  
  const todosCompletados = registros.every(r => r.estado === 'COMPLETADO');
  const algunoValidado = registros.some(r => r.validadoPor && r.validadoPor !== '');
  const algunoCompletado = registros.some(r => r.estado === 'COMPLETADO');
  
  if (algunoValidado) {
    return 'VALIDADO';
  } else if (todosCompletados) {
    return 'COMPLETADO';
  } else if (algunoCompletado) {
    return 'EN-PROCESO';
  } else {
    return 'PENDIENTE';
  }
}

// Funci√≥n para obtener icono seg√∫n estado
function obtenerIconoEstado(estado) {
  switch(estado) {
    case 'VALIDADO': return '<i class="fa-jelly fa-regular fa-thumbs-up"></i>';
    case 'COMPLETADO': return '<i class="fas fa-check-circle"></i>';
    case 'EN-PROCESO': return '<i class="fas fa-spinner"></i>';
    case 'PENDIENTE': return '<i class="fas fa-clock"></i>';
    default: return '<i class="fas fa-question-circle"></i>';
  }
}

function formatFechaSimple(fechaString) {
  if (!fechaString) return '';
  
  try {
    // Usar la funci√≥n segura para evitar problemas de zona horaria
    const fecha = obtenerFechaSinZonaHoraria(fechaString);
    
    // Formatear sin problemas
    return fecha.toLocaleDateString('es-ES', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      timeZone: 'UTC'
    });
  } catch (e) {
    console.warn('‚ö†Ô∏è Error formateando fecha:', fechaString, e);
    // Intentar formato simple
    try {
      const partes = fechaString.split('-');
      if (partes.length === 3) {
        return `${partes[2]}/${partes[1]}/${partes[0]}`;
      }
      return fechaString;
    } catch {
      return fechaString;
    }
  }
}

function calcularTotalComponentes(maquinas) {
  return maquinas.reduce((sum, m) => sum + m.componentes.length, 0);
}

function calcularTotalElementos(maquinas) {
  return maquinas.reduce((sum, m) => sum + m.estadisticas.total, 0);
}

// ==================== EN PROCESO ====================
function loadProceso() {
  showLoading();
  
  // Para GEN, obtener todos los registros
  if (currentUser.proceso === 'GENERAL') {
    google.script.run
      .withSuccessHandler(onProcesoLoaded)
      .withFailureHandler(function(error) {
        hideLoading();
        console.error('Error cargando proceso:', error);
        renderProceso([]);
      })
      .obtenerTodosRegistrosLimpieza(); // ¬°NUEVA FUNCI√ìN!
  } else {
    google.script.run
      .withSuccessHandler(onProcesoLoaded)
      .withFailureHandler(function(error) {
        hideLoading();
        console.error('Error cargando proceso:', error);
        renderProceso([]);
      })
      .obtenerRegistrosLimpiezaPorProceso(currentUser.proceso, null, null);
  }
}

function onProcesoLoaded(result) {
  hideLoading();
  
  if (result && result.success) {
    renderProceso(result.registros || []);
  } else {
    renderProceso([]);
  }
}

function renderProceso(registros) {
  const container = document.getElementById('proceso-content');
  container.innerHTML = '';
  
  if (!registros || registros.length === 0) {
    container.innerHTML = '<p class="config-placeholder">No hay limpiezas en proceso</p>';
    return;
  }
  
  const grouped = {};
  registros.forEach(reg => {
    if (!grouped[reg.maquinaId]) {
      grouped[reg.maquinaId] = {
        nombre: reg.maquinaNombre,
        registros: []
      };
    }
    grouped[reg.maquinaId].registros.push(reg);
  });
  
  Object.keys(grouped).forEach(maquinaId => {
    const maquina = grouped[maquinaId];
    const card = document.createElement('div');
    card.className = 'proceso-card';
    
    const elementosHtml = maquina.registros.slice(0, 5).map(reg => `
      <div class="proceso-elemento">
        <span>${reg.elementoNombre} - ${reg.tipoLimpieza}</span>
        <span class="estado-badge ${reg.estado === 'COMPLETADO' ? 'estado-completado' : 'estado-pendiente'}">
          ${reg.estado}
        </span>
      </div>
    `).join('');
    
    card.innerHTML = `
      <div class="proceso-card-title">${maquina.nombre}</div>
      <div class="proceso-card-elementos">${elementosHtml}</div>
    `;
    
    container.appendChild(card);
  });
}

// ==================== ELEMENTO DETAIL ====================
function selectElemento(maquinaId, elementoId, maquinaNombre, elementoNombre, componenteNombre) {
  // Si el elemento no tiene planeaci√≥n, no permitir ir a limpieza individual
  limpiarSeleccionMasiva();

  if (!tienePlaneacionActiva(elementoId)) {
    showAlert("info", "Sin planeaci√≥n", "Este elemento no tiene planeaci√≥n activa");
    return;
  }
  
  currentMaquinaId = maquinaId;
  currentElementoId = elementoId;
  
  // Si no se pas√≥ el nombre de la m√°quina, buscarlo en los datos
  if (!maquinaNombre && maquinasData) {
    const maquina = maquinasData.find(m => m.id.toString() === maquinaId.toString());
    if (maquina) {
      maquinaNombre = maquina.nombre;
      currentMaquinaNombre = maquina.nombre;
    }
  } else {
    currentMaquinaNombre = maquinaNombre;
  }
  
  // Si no se pas√≥ el nombre del elemento, buscarlo en los datos
  if (!elementoNombre && maquinasData) {
    for (const maquina of maquinasData) {
      if (maquina.id.toString() === maquinaId.toString() && maquina.componentes) {
        for (const componente of maquina.componentes) {
          const elemento = componente.elementos.find(e => e.id.toString() === elementoId.toString());
          if (elemento) {
            elementoNombre = elemento.nombre;
            currentElementoNombre = elemento.nombre;
            componenteNombre = componente.nombre;
            break;
          }
        }
      }
    }
  } else {
    currentElementoNombre = elementoNombre;
  }
  
  console.log('üéØ Elemento seleccionado para limpieza individual:', {
    maquinaId: maquinaId,
    elementoId: elementoId,
    maquinaNombre: currentMaquinaNombre,
    elementoNombre: currentElementoNombre
  });
  
  // Actualizar el t√≠tulo
  const elementoTitle = document.getElementById('elemento-title');
  if (elementoTitle) {
    elementoTitle.textContent = `${currentMaquinaNombre || maquinaId} - ${componenteNombre || ''} - ${currentElementoNombre || elementoId}`;
  }
  
  // Cambiar a la vista de elemento
  document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
  document.getElementById('content-elemento').classList.remove('hidden');
  
  // Resetear selecci√≥n activa en sidebar
  document.querySelectorAll('.elemento-item.active').forEach(item => item.classList.remove('active'));
  
  // Marcar el elemento actual como activo
  const elementoDiv = document.querySelector(`.elemento-item[onclick*="${elementoId}"]`);
  if (elementoDiv) {
    elementoDiv.classList.add('active');
  }
  
  // Ejecutar debug
  debugElementoSeleccionado();
  
  // Cargar los tipos de limpieza
  loadElementoTiposLimpieza();
}

function loadElementoTiposLimpieza() {
  console.log('üîÑ Cargando tipos de limpieza para:', {
    maquinaId: currentMaquinaId,
    elementoId: currentElementoId
  });
  
  showLoading();
  
  google.script.run
    .withSuccessHandler(onTiposLimpiezaLoaded)
    .withFailureHandler(function(error) {
      hideLoading();
      console.error('‚ùå Error cargando tipos de limpieza:', error);
      showNoRegistrosMessage();
    })
    .obtenerRegistrosLimpieza(currentMaquinaId, currentElementoId);
}

function onTiposLimpiezaLoaded(result) {
  hideLoading();
  console.log('üì• Respuesta tipos limpieza:', result);
  
  if (!result) {
    console.error('‚ùå Error: Respuesta nula de tipos limpieza');
    showNoRegistrosMessage();
    return;
  }
  
  if (result.success) {
    currentElementoTiposLimpieza = result.registros || [];
    console.log('‚úÖ Tipos de limpieza cargados:', currentElementoTiposLimpieza.length);
    
    if (currentElementoTiposLimpieza.length === 0) {
      showNoRegistrosMessage();
    } else {
      renderLimpiezaSections();
      // SOLO llamar verificarEstadoValidacion si estamos en la vista correcta
      if (document.getElementById('content-elemento') && 
          !document.getElementById('content-elemento').classList.contains('hidden')) {
        verificarEstadoValidacion();
      }
    }
  } else {
    console.error('‚ùå Error en tipos limpieza:', result.message);
    showNoRegistrosMessage();
  }
}

function showNoRegistrosMessage() {
  const container = document.getElementById('limpieza-sections');
  container.innerHTML = `
    <div class="empty-state">
      <p class="config-placeholder">No hay tipos de limpieza configurados para este elemento</p>
      <p class="empty-state-hint">Este elemento no tiene registros de limpieza pendientes. Verifique:</p>
      <ul style="text-align: left;margin: 1rem 0;font-size: 14.4px;color: var(--text-muted);">
        <li>Que el elemento est√© incluido en una planeaci√≥n activa</li>
        <li>Que la planeaci√≥n tenga tipos de limpieza configurados</li>
        <li>Que los registros se hayan creado correctamente</li>
      </ul>
      <button onclick="loadElementoTiposLimpieza()" class="btn-principal">Reintentar</button>
    </div>
  `;
  document.getElementById('btn-finalizar').classList.add('hidden');
}

function renderLimpiezaSections() {
  const container = document.getElementById('limpieza-sections');
  
  if (!container) {
    console.error('‚ùå Contenedor limpieza-sections no encontrado');
    return;
  }
  
  console.log('üé® Renderizando secciones de limpieza:', currentElementoTiposLimpieza);
  console.log('üë§ Usuario actual:', currentUser);
  
  if (!currentElementoTiposLimpieza || currentElementoTiposLimpieza.length === 0) {
    showNoRegistrosMessage();
    return;
  }
  
  // Verificar si est√° validada
  const primeraLimpieza = currentElementoTiposLimpieza[0];
  const estaValidada = primeraLimpieza.validadoPor && primeraLimpieza.validadoPor !== '';
  
  let html = '';
  
  // Mostrar informaci√≥n de validaci√≥n si existe
  if (estaValidada) {
    html += `
      <div class="validacion-info" style="
        background: rgba(34, 197, 94, 0.1);
        border: 1px solid rgba(34, 197, 94, 0.3);
        border-radius: var(--border-radius);
        padding: 16px;
        margin-bottom: 24px;
        text-align: center;
      ">
        <div style="font-weight: 600; color: #166534; margin-bottom: 8px;">
          ‚úÖ LIMPIEZA VALIDADA
        </div>
        <div style="font-size: 13px; color: #065F46;">
          Validado por: <strong>${primeraLimpieza.validadoPor}</strong><br>
          Fecha: ${primeraLimpieza.fechaValidacion || 'No especificada'}
        </div>
      </div>
    `;
  }
  
  // Agrupar por tipo de limpieza
  const tiposMap = {};
  currentElementoTiposLimpieza.forEach(reg => {
    if (!tiposMap[reg.tipoLimpieza]) {
      tiposMap[reg.tipoLimpieza] = reg;
    }
  });
  
  const tiposOrden = ['SECO', 'HUMEDO', 'DESINFECCION'];
  const tiposNombres = {
    'SECO': 'Limpieza Seco',
    'HUMEDO': 'Limpieza H√∫medo',
    'DESINFECCION': 'Desinfecci√≥n'
  };
  
  tiposOrden.forEach(tipo => {
    if (tiposMap[tipo]) {
      const reg = tiposMap[tipo];
      const isCompleted = reg.estado === 'COMPLETADO' || reg.estado === 'VALIDADO';
      const estaValidada = reg.validadoPor && reg.validadoPor !== '';
      
      // Determinar el valor del responsable
      const responsableValue = reg.responsable && reg.responsable !== '' ? 
        reg.responsable : 
        (currentUser ? currentUser.nombre : '');
      
      html += `
        <div class="limpieza-section">
          <div class="section-header">
            <span class="section-name">${tiposNombres[tipo]}</span>
            <input type="checkbox" class="section-checkbox" id="check-${tipo}" 
              ${isCompleted ? 'checked' : ''} 
              ${isCompleted ? 'disabled' : ''}
              onchange="handleLimpiezaCheckbox('${reg.id}', '${tipo}', this.checked)">
            <div class="section-line"></div>
          </div>
          <div class="section-form ${isCompleted ? 'disabled' : ''}" id="form-${tipo}">
            <div class="form-group">
              <label class="form-label">Nombre del Responsable</label>
              <input type="text" class="input-field" id="responsable-${tipo}" 
                placeholder="Nombre..." value="${responsableValue}" 
                ${isCompleted ? 'disabled' : ''}
                ${!isCompleted ? 'readonly' : ''}
                style="${!isCompleted ? 'background-color: #f3f4f6;' : ''}">
              ${!isCompleted ? '<small class="form-hint">El nombre se asigna autom√°ticamente</small>' : ''}
            </div>
            <div class="form-group">
              <label class="form-label">Fecha en que se realiz√≥</label>
              <input type="date" class="input-field" id="fecha-${tipo}" 
                value="${reg.fechaRealizacion || ''}" 
                ${isCompleted ? 'disabled' : ''}>
            </div>
            <div class="form-group">
              <label class="form-label">Observaciones</label>
              <textarea class="textarea-field" id="observaciones-${tipo}" 
                placeholder="Observaciones..." 
                ${isCompleted ? 'disabled' : ''}>${reg.observaciones || ''}</textarea>
            </div>
            ${estaValidada ? `
              <div class="validacion-detalle" style="
                background: rgba(34, 197, 94, 0.05);
                border: 1px solid rgba(34, 197, 94, 0.2);
                border-radius: 6px;
                padding: 12px;
                margin-top: 12px;
                font-size: 12px;
                color: #065F46;
              ">
                <strong>Validado por:</strong> ${reg.validadoPor}<br>
                <strong>Fecha validaci√≥n:</strong> ${reg.fechaValidacion || 'No especificada'}
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }
  });
  
  container.innerHTML = html;
  console.log('‚úÖ Secciones de limpieza renderizadas correctamente');
}

function handleLimpiezaCheckbox(registroId, tipo, isChecked) {
  if (isChecked) {
    pendingCheckboxData = {
      registroId: registroId,
      tipo: tipo
    };
    
    document.getElementById('modal-message').textContent = 
      `¬øEst√° seguro que desea marcar la limpieza "${tipo}" como completada? Esta acci√≥n no se puede deshacer.`;
    document.getElementById('confirm-modal').classList.remove('hidden');
  }
}

function confirmarModal() {
  // Si hay finalizaci√≥n completa pendiente
  if (window.pendingFinalizarCompleto) {
    confirmarFinalizarCompleto();
    cerrarModal();
    return;
  }
  
  // Si hay reporte de m√°quina pendiente
  if (window.pendingReporteMaquina) {
    ejecutarGenerarReporteMaquina();
    cerrarModal();
    return;
  }
  
  // Si hay validaci√≥n pendiente
  if (pendingValidation) {
    confirmarValidacion();
    cerrarModal();
    return;
  }
  
  // Si hay checkbox de limpieza pendiente
  if (pendingCheckboxData) {
    confirmarLimpieza();
    cerrarModal();
    return;
  }
  
  // Si hay eliminaci√≥n de m√°quina pendiente
  if (window.pendingMaquinaDelete) {
    ejecutarEliminacionMaquina();
    cerrarModal();
    return;
  }
  
  // Si hay validaci√≥n de m√°quina pendiente
  if (window.pendingMaquinaValidation) {
    ejecutarValidacionMaquina();
    cerrarModal();
    return;
  }

  if (window.pendingFinalizarCompleto) {
        confirmarFinalizarCompleto();
        cerrarModal();
        return;
    }

  if (window.pendingLimpiezaMasiva) {
        confirmarLimpiezaMasiva();
        cerrarModal();
        return;
    }
}

function cerrarModal() {
    document.getElementById('confirm-modal').classList.add('hidden');
    
    // Limpiar todos los estados pendientes
    if (window.pendingLimpiezaMasiva) {
        // Si se cancela la limpieza masiva, volver a mostrar el modal de limpieza masiva
        setTimeout(() => {
            const modalLimpiezaMasiva = document.getElementById('limpieza-masiva-modal');
            if (modalLimpiezaMasiva) {
                modalLimpiezaMasiva.classList.remove('hidden');
            }
        }, 100);
        window.pendingLimpiezaMasiva = null;
    }
    
    // A√±adir limpieza para cambios de frecuencia pendientes
    if (window.pendingFrecuenciaChange) {
        // Si se cancela el cambio de frecuencia, restaurar valor anterior
        obtenerFrecuenciaActualYRestaurar(window.pendingFrecuenciaChange.maquinaId);
        window.pendingFrecuenciaChange = null;
    }
    
    // Restablecer el modal
    const modalTitle = document.querySelector('.modal-title');
    if (modalTitle) {
        modalTitle.textContent = 'Confirmar Validaci√≥n';
    }
    
    const confirmBtn = document.querySelector('.btn-confirm');
    if (confirmBtn) {
        confirmBtn.disabled = false;
        confirmBtn.style.opacity = '1';
        confirmBtn.style.cursor = 'pointer';
        confirmBtn.textContent = 'Confirmar';
        confirmBtn.style.backgroundColor = '';
        confirmBtn.style.borderColor = '';
        // Restaurar el event listener original
        confirmBtn.onclick = confirmarModal;
    }
    
    const cancelBtn = document.querySelector('.btn-cancel');
    if (cancelBtn) {
        cancelBtn.textContent = 'Cancelar';
        // Restaurar el event listener original
        cancelBtn.onclick = cerrarModal;
    }
    
    // Limpiar otros estados pendientes
    if (pendingCheckboxData) {
        const checkbox = document.getElementById('check-' + pendingCheckboxData.tipo);
        if (checkbox) checkbox.checked = false;
        pendingCheckboxData = null;
    }
  
    if (window.pendingMaquinaDelete) {
        window.pendingMaquinaDelete = null;
    }
  
    if (window.pendingMaquinaValidation) {
        window.pendingMaquinaValidation = null;
    }
  
    if (window.pendingReporteMaquina) {
        window.pendingReporteMaquina = null;
    }
  
    if (window.pendingFinalizarCompleto) {
        window.pendingFinalizarCompleto = null;
    }
  
    pendingValidation = false;
  
    // Limpiar campos de confirmaci√≥n
    const confirmInput = document.getElementById('confirm-delete-input');
    if (confirmInput) {
        confirmInput.value = '';
    }
  
    const errorMsg = document.getElementById('confirm-delete-error');
    if (errorMsg) {
        errorMsg.style.display = 'none';
    }
}

function cerrarModalAlClicarFuera(event) {
    const modal = document.getElementById('limpieza-masiva-modal');
    if (modal && !modal.classList.contains('hidden')) {
        // Si el clic fue en el fondo (no en el contenido del modal)
        if (event.target === modal) {
            cerrarModalLimpiezaMasiva();
        }
    }
}

// A√±ade este evento al cargar la p√°gina
document.addEventListener('DOMContentLoaded', function() {
    const cedulaInput = document.getElementById('cedula-input');
    if (cedulaInput) {
        cedulaInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                handleLogin();
            }
        });
    }
    
    // A√±adir evento para cerrar modal al hacer clic fuera - SOLO UNA VEZ
    document.addEventListener('click', cerrarModalAlClicarFuera);
});

function confirmarLimpieza() {
  if (!pendingCheckboxData) {
    cerrarModal();
    return;
  }
  
  const tipo = pendingCheckboxData.tipo;
  const registroId = pendingCheckboxData.registroId;
  
  // Obtener valores del formulario
  const responsableInput = document.getElementById('responsable-' + tipo);
  const fechaInput = document.getElementById('fecha-' + tipo);
  const observacionesInput = document.getElementById('observaciones-' + tipo);
  
  // El responsable ahora es autom√°tico, pero verificar que est√© presente
  const responsable = currentUser ? currentUser.nombre : 
                    (responsableInput ? responsableInput.value : '');
  const fecha = fechaInput ? fechaInput.value : '';
  const observaciones = observacionesInput ? observacionesInput.value : '';
  
  // Validaciones
  if (!responsable || responsable.trim() === '') {
    showAlert("error", "¬°Error!", "No se pudo obtener el nombre del usuario. Cierre sesi√≥n y vuelva a ingresar.");
    const checkbox = document.getElementById('check-' + tipo);
    if (checkbox) checkbox.checked = false;
    cerrarModal();
    return;
  }
  
  if (!fecha) {
    showAlert("info", "¬°Upss!", "Por favor seleccione la fecha en que realiz√≥ la limpieza");
    const checkbox = document.getElementById('check-' + tipo);
    if (checkbox) checkbox.checked = false;
    cerrarModal();
    return;
  }
  
  // Validar que la fecha no sea futura
  const fechaSeleccionada = new Date(fecha);
  const hoy = new Date();
  hoy.setHours(0, 0, 0, 0);
  
  if (fechaSeleccionada > hoy) {
    showAlert("warning", "Fecha inv√°lida", "No puede seleccionar una fecha futura");
    const checkbox = document.getElementById('check-' + tipo);
    if (checkbox) checkbox.checked = false;
    cerrarModal();
    return;
  }
  
  cerrarModal();
  showLoading();
  
  const datos = {
    estado: 'COMPLETADO',
    responsable: responsable.trim(),
    fechaRealizacion: fecha,
    observaciones: observaciones.trim()
  };
  
  console.log('üì§ Enviando datos de limpieza:', datos);
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      if (result && result.success) {
        showAlert("success", "¬°√âxito!", "Limpieza registrada correctamente");
        loadElementoTiposLimpieza();
        actualizarEstadosSidebar(); 
      } else {
        showAlert('error', 'Error', 'Error al registrar: ' + (result ? result.message : 'Error desconocido'));
        const checkbox = document.getElementById('check-' + tipo);
        if (checkbox) checkbox.checked = false;
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showAlert('error', 'Error', 'Error de conexi√≥n: ' + error.message);
      const checkbox = document.getElementById('check-' + tipo);
      if (checkbox) checkbox.checked = false;
    })
    .actualizarRegistroLimpiezaCompleto(registroId, datos);
  
  pendingCheckboxData = null;
}

function debugElementoSeleccionado() {
  console.log('üîç DEBUG Elemento Seleccionado:');
  console.log('Maquina ID:', currentMaquinaId, 'Tipo:', typeof currentMaquinaId);
  console.log('Elemento ID:', currentElementoId, 'Tipo:', typeof currentElementoId);
  console.log('Maquina Nombre:', currentMaquinaNombre);
  console.log('Elemento Nombre:', currentElementoNombre);
  
  // Primero probar con la funci√≥n de debug espec√≠fica
  google.script.run
    .withSuccessHandler(function(result) {
      console.log('üêõ DEBUG ESPEC√çFICO Resultado:', result);
    })
    .debugRegistrosElemento(currentMaquinaId, currentElementoId);
  
  // Luego con la funci√≥n normal - CAMBIADO TAMBI√âN
  google.script.run
    .withSuccessHandler(function(result) {
      console.log('üìä Registros encontrados (funci√≥n normal):', result);
      if (result && result.success) {
        console.log('Total registros:', result.registros.length);
        result.registros.forEach(reg => {
          console.log('Registro:', reg);
        });
      } else {
        console.log('Error:', result ? result.message : 'Resultado nulo');
      }
    })
    .obtenerRegistrosLimpieza(currentMaquinaId, currentElementoId); // ‚Üê CAMBIADO AQU√ç
}

function ejecutarDiagnostico() {
  console.log('üõ†Ô∏è Ejecutando diagn√≥stico...');
  
  google.script.run
    .withSuccessHandler(function(result) {
      console.log('üìã Resultado diagn√≥stico:', result);
      if (result.success) {
        showAlert("success", "Diagn√≥stico completado", `Revisa la consola para detalles.\nTotal registros: ${result.diagnostico.totalRegistros}`);
} else {
  showAlert('error', 'Error en diagn√≥stico', result.message);
}
    })
    .diagnosticarRegistros();
}

function verificarEstadoValidacion() {
  const btnValidarJefe = document.getElementById('btn-validar-jefe');
  const btnFinalizar = document.getElementById('btn-finalizar');
  
  // VERIFICAR SI LOS ELEMENTOS EXISTEN
  if (!btnValidarJefe || !btnFinalizar) {
    console.log('‚ö†Ô∏è Elementos de validaci√≥n no encontrados. Puede no estar en la vista de elemento.');
    return; // Salir si no existen los elementos
  }
  
  // Ocultar ambos botones inicialmente
  btnValidarJefe.classList.add('hidden');
  btnFinalizar.classList.add('hidden');
  
  // Verificar si el usuario es jefe
  if (currentUser && currentUser.rol === 'jefe') {
    console.log('üëë Usuario es jefe, verificando estado de limpieza...');
    
    // Verificar si todas las limpiezas est√°n completadas pero no validadas
    const todasCompletadas = currentElementoTiposLimpieza.every(r => r.estado === 'COMPLETADO');
    const yaValidada = currentElementoTiposLimpieza.some(r => r.validadoPor && r.validadoPor !== '');
    
    console.log('üìä Estado limpieza - Todas completadas:', todasCompletadas, 'Ya validada:', yaValidada);
    
    if (todasCompletadas && !yaValidada) {
      // Mostrar bot√≥n de validaci√≥n para jefes
      btnValidarJefe.classList.remove('hidden');
      console.log('‚úÖ Mostrando bot√≥n de validaci√≥n para jefe');
    }
  } else {
    console.log('üë§ Usuario no es jefe, rol:', currentUser ? currentUser.rol : 'No definido');
  }
  
  // Mostrar bot√≥n de finalizar normal para todos los usuarios
  // cuando hay limpiezas pendientes
  const pendientes = currentElementoTiposLimpieza.filter(r => r.estado !== 'COMPLETADO');
  if (pendientes.length > 0) {
    btnFinalizar.classList.remove('hidden');
  }
}

function validarLimpiezaCompleta() {
  if (!currentUser || currentUser.rol !== 'jefe') {
    showAlert('error', 'Permiso denegado', 'Solo los jefes pueden validar limpiezas completadas');
    return;
  }
  
  // Verificar que todas las limpiezas est√©n completadas
  const pendientes = currentElementoTiposLimpieza.filter(r => r.estado !== 'COMPLETADO');
  if (pendientes.length > 0) {
    showAlert('error', 'No se puede validar', `A√∫n hay ${pendientes.length} limpieza(s) pendiente(s).`);
    return;
  }
  
  // Verificar que no est√© ya validada
  const yaValidada = currentElementoTiposLimpieza.some(r => r.validadoPor && r.validadoPor !== '');
  if (yaValidada) {
    showAlert("info", "Ya validado", `Esta limpieza ya fue validada por: ${currentElementoTiposLimpieza[0].validadoPor}`);
    return;
  }
  
  // Mostrar modal de confirmaci√≥n
  document.getElementById('modal-message').textContent = 
    `¬øEst√° seguro que desea validar esta limpieza completa?\n\n` +
    `Elemento: ${currentElementoNombre}\n` +
    `M√°quina: ${currentMaquinaNombre}\n\n` +
    `Esta acci√≥n registrar√° su nombre como validador y no se puede deshacer.`;
  
  document.getElementById('confirm-modal').classList.remove('hidden');
  
  // Configurar el callback para la validaci√≥n
  pendingValidation = true;
}

// Funci√≥n espec√≠fica para confirmar validaci√≥n
function confirmarValidacion() {
  if (!pendingValidation) return;
  
  cerrarModal();
  showLoading();
  
  console.log('‚úÖ Validando limpieza completa...', {
    maquinaId: currentMaquinaId,
    elementoId: currentElementoId,
    validador: currentUser.nombre
  });
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      if (result && result.success) {
        showAlert("success", "¬°Validaci√≥n exitosa!", `Limpieza validada correctamente por ${currentUser.nombre}`);
        loadElementoTiposLimpieza();
        actualizarEstadosSidebar(); // Actualizar estados
      } else {
        showAlert('error', 'Error al validar', result ? result.message : 'Error desconocido');
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showAlert('error', 'Error de conexi√≥n', error.message);
    })
    .validarLimpiezaCompleta(currentMaquinaId, currentElementoId, currentUser.nombre);
  
  pendingValidation = false;
}

    function showAlert(type, title, message, duration = 5000) {
        // Create alert container if it doesn't exist
        let alertContainer = document.getElementById('alertContainer');
        if (!alertContainer) {
            alertContainer = document.createElement('div');
            alertContainer.id = 'alertContainer';
            alertContainer.className = 'alert-container';
            document.body.appendChild(alertContainer);
        }

        // Create alert element
        const alert = document.createElement('div');
        alert.className = `alert ${type}`;
        
        const iconSymbols = {
            success: '‚úì',
            error: '‚úï',
            warning: '‚ö†',
            info: 'i'
        };

        alert.innerHTML = `
            <div class="alert-icon">${iconSymbols[type] || 'i'}</div>
            <div class="alert-content">
                <div class="alert-title">${title}</div>
                <div class="alert-message">${message}</div>
            </div>
            <button class="alert-close" onclick="closeAlert(this)">&times;</button>
            <div class="alert-progress"></div>
        `;

        alertContainer.appendChild(alert);

        // Show alert with animation
        setTimeout(() => {
            alert.classList.add('show');
        }, 100);

        // Auto remove alert
        setTimeout(() => {
            closeAlert(alert.querySelector('.alert-close'));
        }, duration);
    }

    function closeAlert(closeBtn) {
        const alert = closeBtn.closest('.alert');
        alert.classList.remove('show');
        setTimeout(() => {
            if (alert.parentNode) {
                alert.parentNode.removeChild(alert);
            }
        }, 400);
    }
  
  // ==================== FUNCIONES DE ESTADOS ====================

function cargarEstadosElementos() {
    return new Promise((resolve) => {
        console.log('üîÑ Cargando estados de elementos y planeaciones...');
        
        // Reset cache
        estadosElementosCache = {};
        
        // Primero cargar planeaciones para saber qu√© elementos tienen planeaci√≥n
        verificarElementosPlaneados().then(() => {
            // Luego obtener registros de limpieza
            google.script.run
                .withSuccessHandler(function(result) {
                    if (result && result.success) {
                        const registros = result.registros || [];
                        
                        // Agrupar registros por elemento
                        const registrosPorElemento = {};
                        registros.forEach(registro => {
                            const elementoId = registro.elementoId;
                            if (!registrosPorElemento[elementoId]) {
                                registrosPorElemento[elementoId] = [];
                            }
                            registrosPorElemento[elementoId].push(registro);
                        });
                        
                        // Determinar estado de cada elemento que tiene planeaci√≥n
                        window.elementosConPlaneacion.forEach(elementoId => {
                            const registrosElemento = registrosPorElemento[elementoId] || [];
                            estadosElementosCache[elementoId] = {
                                estado: determinarEstadoPorRegistros(registrosElemento),
                                // Obtener responsable del primer registro (si existe)
                                responsable: registrosElemento.length > 0 ? 
                                           (registrosElemento[0].responsableAsignado || 'OPERARIO') : 
                                           'OPERARIO'
                            };
                        });
                        
                        console.log('‚úÖ Estados cargados para', Object.keys(estadosElementosCache).length, 'elementos planeados');
                        
                        resolve();
                    } else {
                        console.log('‚ö†Ô∏è No se pudieron cargar estados');
                        resolve();
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('‚ùå Error cargando estados:', error);
                    resolve();
                })
                .obtenerRegistrosLimpiezaPorProceso(currentUser ? currentUser.proceso : 'GENERAL', null, null);
        });
    });
}

// Modificar la funci√≥n obtenerResponsableElemento para usar el cache:
function obtenerResponsableElemento(elementoId) {
    // Primero verificar en selectedElementosConfig (si est√° siendo configurado)
    if (selectedElementosConfig[elementoId] && selectedElementosConfig[elementoId].responsable) {
        return selectedElementosConfig[elementoId].responsable;
    }
    
    // Luego verificar en cache de estados
    if (estadosElementosCache[elementoId] && estadosElementosCache[elementoId].responsable) {
        return estadosElementosCache[elementoId].responsable;
    }
    
    // Valor por defecto
    return 'OPERARIO';
}

// Modificar funci√≥n determinarEstadoElemento:
function determinarEstadoElemento(elementoId) {
    if (estadosElementosCache[elementoId]) {
        return estadosElementosCache[elementoId].estado;
    }
    return 'no-planeado';
}

// Funci√≥n para determinar estado de un elemento basado en sus registros
function determinarEstadoPorRegistros(registros) {
    if (!registros || registros.length === 0) {
        return 'pendiente'; // Si no hay registros pero tiene planeaci√≥n, est√° pendiente
    }
    
    const totalRegistros = registros.length;
    const completados = registros.filter(r => r.estado === 'COMPLETADO').length;
    const validados = registros.filter(r => r.validadoPor && r.validadoPor !== '').length;
    
    if (validados > 0) {
        return 'terminado'; // AZUL - Validado por jefe (COMPLETADO)
    } else if (completados === totalRegistros) {
        return 'en-proceso'; // VERDE - Todos completados pero no validados (COMPLETADO)
    } else if (completados > 0) {
        return 'empezado'; // AMARILLO - Algunos completados (EN PROCESO)
    } else {
        return 'pendiente'; // ROJO - Planeado pero no empezado (PENDIENTE)
    }
}

// Funci√≥n para determinar estado de un componente
function determinarEstadoComponente(maquinaId, componenteId) {
  const maquina = maquinasData.find(m => m.id.toString() === maquinaId.toString());
  if (!maquina || !maquina.componentes) return 'no-planeado';
  
  const componente = maquina.componentes.find(c => c.id.toString() === componenteId.toString());
  if (!componente || !componente.elementos) return 'no-planeado';
  
  const estadosElementos = componente.elementos.map(elem => 
    determinarEstadoElemento(elem.id)
  );
  
  // Si todos los elementos est√°n terminados
  if (estadosElementos.every(estado => estado === 'terminado')) {
    return 'terminado';
  }
  
  // Si todos est√°n en proceso
  if (estadosElementos.every(estado => estado === 'en-proceso')) {
    return 'en-proceso';
  }
  
  // Si hay al menos uno empezado
  if (estadosElementos.some(estado => estado === 'empezado' || estado === 'en-proceso' || estado === 'terminado')) {
    return 'empezado';
  }
  
  return 'no-planeado';
}

// Funci√≥n para determinar estado de una m√°quina
function determinarEstadoMaquina(maquinaId) {
  const maquina = maquinasData.find(m => m.id.toString() === maquinaId.toString());
  if (!maquina || !maquina.componentes) return 'no-planeado';
  
  const estadosComponentes = maquina.componentes.map(componente => 
    determinarEstadoComponente(maquinaId, componente.id)
  );
  
  // Si todos los componentes est√°n terminados
  if (estadosComponentes.every(estado => estado === 'terminado')) {
    return 'terminado';
  }
  
  // Si todos est√°n en proceso
  if (estadosComponentes.every(estado => estado === 'en-proceso')) {
    return 'en-proceso';
  }
  
  // Si hay al menos uno empezado
  if (estadosComponentes.some(estado => estado === 'empezado' || estado === 'en-proceso' || estado === 'terminado')) {
    return 'empezado';
  }
  
  return 'no-planeado';
}

// Funci√≥n para actualizar estados despu√©s de cambios
function actualizarEstadosSidebar() {
    console.log('üîÑ Actualizando estados del sidebar...');
    
     renderSidebarMaquinas();
}

function refrescarEstados() {
  showAlert("info", "Actualizando", "Refrescando estados de elementos...");
  actualizarEstadosSidebar();
}

function actualizarIndicadorProceso() {
  const container = document.getElementById('proceso-indicator');
  if (!container) return;
  
  const procesos = {
    'PASTIFICIO': { nombre: 'Pastificio', color: '#ef4444' },
    'EMPAQUE': { nombre: 'Empaque', color: '#10b981' },
    'MANTENIMIENTO': { nombre: 'Mantenimiento', color: '#f59e0b' },
    'CALIDAD': { nombre: 'Calidad', color: '#8b5cf6' },
    'GENERAL': { nombre: 'General', color: '#6b7280' }
  };
  
  const proceso = currentUser.proceso || 'GENERAL';
  const info = procesos[proceso] || { nombre: proceso, color: '#6b7280' };
  
  container.innerHTML = `
    <span>Proceso: </span>
    <span class="proceso-badge" style="background: ${info.color}">
      ${info.nombre}
    </span>
  `;
}

// ==================== ELIMINAR PLANEACI√ìN (CON MODAL) ====================
function eliminarPlaneacionMaquina(maquinaId, maquinaNombre) {
  // Guardar los datos en variables globales para usarlos en la confirmaci√≥n
  window.pendingMaquinaDelete = {
    maquinaId: maquinaId,
    maquinaNombre: maquinaNombre
  };
  
  // Configurar el mensaje del modal
  const modalMessage = document.getElementById('modal-message');
  modalMessage.innerHTML = `
    <div style="text-align: left;">
      <strong>¬øEst√° seguro que desea eliminar todas las planeaciones de la m√°quina?</strong>
      <br><br>
      <div style="background: #fef3c7; padding: 12px; border-radius: 6px; border-left: 4px solid #f59e0b; margin: 10px 0;">
        <div style="font-weight: 600; color: #92400e; margin-bottom: 4px;">
          <i class="fas fa-exclamation-triangle"></i> M√ÅQUINA A ELIMINAR:
        </div>
        <div style="color: #78350f; font-size: 14px;">
          <strong>${maquinaNombre}</strong> (ID: ${maquinaId})
        </div>
      </div>
      
      <div style="font-size: 13px; color: #4b5563; margin: 12px 0;">
        <p style="margin: 8px 0;"><i class="fas fa-trash"></i> Esta acci√≥n eliminar√°:</p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>Todas las planeaciones de esta m√°quina</li>
          <li>Todos los registros de limpieza asociados</li>
          <li>Los elementos configurados en la planeaci√≥n</li>
        </ul>
        <p style="margin: 8px 0; color: #dc2626; font-weight: 600;">
          <i class="fas fa-exclamation-circle"></i> ¬°Esta acci√≥n no se puede deshacer!
        </p>
      </div>
      
      <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid #e5e7eb; font-size: 12px; color: #6b7280;">
        Para confirmar, escriba el nombre de la m√°quina: 
        <input type="text" id="confirm-delete-input" 
               placeholder="Escriba '${maquinaNombre}' aqu√≠" 
               style="width: 100%; padding: 8px; margin-top: 8px; border: 1px solid #d1d5db; border-radius: 4px;"
               onkeyup="validarConfirmacionEliminacion()">
        <div id="confirm-delete-error" style="color: #dc2626; font-size: 11px; margin-top: 4px; display: none;">
          El nombre no coincide
        </div>
      </div>
    </div>
  `;
  
  // Cambiar el t√≠tulo del modal
  const modalTitle = document.querySelector('.modal-title');
  if (modalTitle) {
    modalTitle.textContent = 'Confirmar Eliminaci√≥n';
  }
  
  // Configurar los botones del modal
  const confirmBtn = document.querySelector('.btn-confirm');
  const cancelBtn = document.querySelector('.btn-cancel');
  
  if (confirmBtn) {
    confirmBtn.disabled = true;
    confirmBtn.style.opacity = '0.5';
    confirmBtn.style.cursor = 'not-allowed';
    confirmBtn.textContent = 'Eliminar';
    
    // Cambiar color para eliminar (rojo)
    confirmBtn.style.backgroundColor = '#dc2626';
    confirmBtn.style.borderColor = '#dc2626';
  }
  
  if (cancelBtn) {
    cancelBtn.textContent = 'Cancelar';
  }
  
  // Mostrar el modal
  document.getElementById('confirm-modal').classList.remove('hidden');
}

// Funci√≥n para ejecutar la eliminaci√≥n despu√©s de la confirmaci√≥n
function ejecutarEliminacionMaquina() {
  if (!window.pendingMaquinaDelete) {
    cerrarModal();
    return;
  }
  
  const { maquinaId, maquinaNombre } = window.pendingMaquinaDelete;
  
  cerrarModal();
  showLoading();
  
  console.log('üóëÔ∏è Eliminando planeaciones de m√°quina:', { maquinaId, maquinaNombre });
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      if (result && result.success) {
        showAlert("success", "¬°Eliminado!", result.message);
        loadPlaneaciones(); // Recargar el consolidado
        actualizarEstadosSidebar(); // Actualizar sidebar
        
        // Limpiar cache de estados
        estadosElementosCache = {};
      } else {
        showAlert('error', 'Error al eliminar', result ? result.message : 'Error desconocido');
      }
      window.pendingMaquinaDelete = null;
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showAlert('error', 'Error de conexi√≥n', error.message);
      window.pendingMaquinaDelete = null;
    })
    .eliminarPlaneacionesMaquina(maquinaId);
}

// Funci√≥n para validar que el nombre coincida
function validarConfirmacionEliminacion() {
  const input = document.getElementById('confirm-delete-input');
  const confirmBtn = document.querySelector('.btn-confirm');
  const errorMsg = document.getElementById('confirm-delete-error');
  
  if (!input || !confirmBtn || !window.pendingMaquinaDelete) return;
  
  const nombreIngresado = input.value.trim();
  const nombreCorrecto = window.pendingMaquinaDelete.maquinaNombre;
  
  if (nombreIngresado === nombreCorrecto) {
    confirmBtn.disabled = false;
    confirmBtn.style.opacity = '1';
    confirmBtn.style.cursor = 'pointer';
    if (errorMsg) errorMsg.style.display = 'none';
  } else {
    confirmBtn.disabled = true;
    confirmBtn.style.opacity = '0.5';
    confirmBtn.style.cursor = 'not-allowed';
    if (errorMsg && nombreIngresado !== '') {
      errorMsg.style.display = 'block';
    } else if (errorMsg) {
      errorMsg.style.display = 'none';
    }
  }
}

// ==================== VALIDACI√ìN DESDE CONSOLIDADO ====================
function validarMaquinaCompleta(maquinaId, maquinaNombre) {
  // VALIDACI√ìN CR√çTICA: Verificar que maquinaId no sea undefined
  console.log('üîç Validar m√°quina llamado con:', { maquinaId, maquinaNombre });
  
  if (!maquinaId || maquinaId === 'undefined' || maquinaId.trim() === '') {
    console.error('‚ùå ERROR: maquinaId es inv√°lido:', maquinaId);
    showAlert('error', 'Error', 'ID de m√°quina inv√°lido. No se puede validar.');
    return;
  }
  
  if (!currentUser || currentUser.rol !== 'jefe') {
    showAlert('error', 'Permiso denegado', 'Solo los jefes pueden validar limpiezas completadas');
    return;
  }
  
  showLoading();
  
  console.log('‚úÖ Par√°metros v√°lidos, llamando backend con maquinaId:', maquinaId);
  
  // Obtener informaci√≥n de la m√°quina
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      console.log('üì• Respuesta de obtenerInfoValidacionMaquina:', result);
      
      if (result && result.success) {
        console.log('üìä Informaci√≥n de m√°quina obtenida:', result.datos);
        mostrarModalValidacionMaquina(maquinaId, maquinaNombre, result.datos);
      } else {
        console.error('‚ùå Error obteniendo info:', result ? result.message : 'Sin respuesta');
        showAlert('error', 'Error', result ? result.message : 'Error al obtener informaci√≥n');
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      console.error('‚ùå Error de conexi√≥n:', error);
      showAlert('error', 'Error de conexi√≥n', error.message);
    })
    .obtenerInfoValidacionMaquina(maquinaId);
}

function mostrarModalValidacionMaquina(maquinaId, maquinaNombre, datos) {
  window.pendingMaquinaValidation = {
    maquinaId: maquinaId,
    maquinaNombre: maquinaNombre,
    datos: datos
  };
  
  const puedeValidar = datos.puedeValidar;
  const detalles = `
    <strong>¬øEst√° seguro que desea validar toda la limpieza de esta m√°quina?</strong>
    <br><br>
    <div style="background: ${puedeValidar ? '#f0f9ff' : '#fef3c7'}; padding: 12px; border-radius: 6px; border-left: 4px solid ${puedeValidar ? '#0ea5e9' : '#f59e0b'}; margin: 10px 0;">
      <div style="font-weight: 600; color: ${puedeValidar ? '#0369a1' : '#92400e'}; margin-bottom: 4px;">
        <i class="fas fa-industry"></i> M√ÅQUINA A VALIDAR:
      </div>
      <div style="color: ${puedeValidar ? '#0c4a6e' : '#78350f'}; font-size: 14px;">
        <strong>${maquinaNombre}</strong> (ID: ${maquinaId})
      </div>
    </div>
    
    <div style="font-size: 13px; color: #4b5563; margin: 12px 0;">
      <p style="margin: 8px 0; font-weight: 600;">Estado actual de la limpieza:</p>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 10px 0;">
        <div style="background: #dcfce7; padding: 8px; border-radius: 4px;">
          <div style="font-size: 11px; color: #166534;">Completados</div>
          <div style="font-weight: 600; color: #166534;">${datos.completados}/${datos.total}</div>
        </div>
        <div style="background: #fef3c7; padding: 8px; border-radius: 4px;">
          <div style="font-size: 11px; color: #92400e;">Pendientes</div>
          <div style="font-weight: 600; color: #92400e;">${datos.pendientes}</div>
        </div>
        ${datos.yaValidados > 0 ? `
        <div style="background: #dbeafe; padding: 8px; border-radius: 4px;">
          <div style="font-size: 11px; color: #1e40af;">Ya validados</div>
          <div style="font-weight: 600; color: #1e40af;">${datos.yaValidados}</div>
        </div>
        ` : ''}
      </div>
      
      ${puedeValidar ? `
        <div style="background: #ecfdf5; padding: 10px; border-radius: 6px; border: 1px solid #d1fae5; margin: 12px 0;">
          <div style="display: flex; align-items: center; gap: 8px; color: #065f46;">
            <i class="fas fa-check-circle"></i>
            <span>‚úÖ Todos los elementos est√°n completamente limpiados y listos para validar</span>
          </div>
        </div>
      ` : datos.completados === datos.total && datos.yaValidados > 0 ? `
        <div style="background: #e0e7ff; padding: 10px; border-radius: 6px; border: 1px solid #c7d2fe; margin: 12px 0;">
          <div style="display: flex; align-items: center; gap: 8px; color: #3730a3;">
            <i class="fas fa-info-circle"></i>
            <span>‚ÑπÔ∏è Esta m√°quina ya tiene ${datos.yaValidados} elemento(s) validados</span>
          </div>
        </div>
      ` : `
        <div style="background: #fef3c7; padding: 10px; border-radius: 6px; border: 1px solid #fde68a; margin: 12px 0;">
          <div style="display: flex; align-items: center; gap: 8px; color: #92400e;">
            <i class="fas fa-exclamation-triangle"></i>
            <span>‚ö†Ô∏è No se puede validar. A√∫n hay ${datos.pendientes} elemento(s) pendientes.</span>
          </div>
        </div>
      `}
      
      ${puedeValidar ? `
        <p style="margin: 8px 0; color: #059669; font-weight: 600;">
          <i class="fa-jelly fa-regular fa-thumbs-up"></i> Esta acci√≥n registrar√° su nombre como validador de todos los elementos.
        </p>
      ` : ''}
    </div>
  `;
  
  document.getElementById('modal-message').innerHTML = detalles;
  
  // Cambiar el t√≠tulo del modal
  const modalTitle = document.querySelector('.modal-title');
  if (modalTitle) {
    modalTitle.textContent = 'Validar Limpieza Completa';
  }
  
  // Configurar botones del modal
  const confirmBtn = document.querySelector('.btn-confirm');
  const cancelBtn = document.querySelector('.btn-cancel');
  
  if (confirmBtn) {
    confirmBtn.disabled = !puedeValidar;
    confirmBtn.style.opacity = puedeValidar ? '1' : '0.5';
    confirmBtn.style.cursor = puedeValidar ? 'pointer' : 'not-allowed';
    confirmBtn.textContent = 'Validar';
    confirmBtn.style.backgroundColor = puedeValidar ? '#10b981' : '#9ca3af';
    confirmBtn.style.borderColor = puedeValidar ? '#10b981' : '#9ca3af';
  }
  
  if (cancelBtn) {
    cancelBtn.textContent = 'Cancelar';
  }
  
  // Mostrar el modal
  document.getElementById('confirm-modal').classList.remove('hidden');
}

function ejecutarValidacionMaquina() {
  if (!window.pendingMaquinaValidation) {
    cerrarModal();
    return;
  }
  
  const { maquinaId, maquinaNombre } = window.pendingMaquinaValidation;
  
  cerrarModal();
  showLoading();
  
  console.log('‚úÖ Validando m√°quina completa:', { maquinaId, maquinaNombre });
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      if (result && result.success) {
        showAlert("success", "¬°Validaci√≥n exitosa!", 
          `La m√°quina "${maquinaNombre}" ha sido validada completamente.\n` +
          `Elementos validados: ${result.elementosValidados || 0}`);
        
        // Recargar el consolidado
        loadPlaneaciones();
        
        // Actualizar estados en sidebar
        actualizarEstadosSidebar();
      } else {
        showAlert('error', 'Error al validar', result ? result.message : 'Error desconocido');
      }
      window.pendingMaquinaValidation = null;
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showAlert('error', 'Error de conexi√≥n', error.message);
      window.pendingMaquinaValidation = null;
    })
    .validarMaquinaCompletaPorJefe(maquinaId, currentUser.nombre);
}

// ==================== FUNCIONES DE TURNO ====================

function obtenerTurnoActual() {
  const horaActual = new Date().getHours();
  
  // MA√ëANA: 6:00 AM - 1:59 PM (6 a 13 horas)
  // TARDE: 2:00 PM - 9:59 PM (14 a 21 horas)
  // NOCHE: 10:00 PM - 5:59 AM (22 a 5 horas)
  
  if (horaActual >= 6 && horaActual < 14) {
    return 'MA√ëANA';
  } else if (horaActual >= 14 && horaActual < 22) {
    return 'TARDE';
  } else {
    return 'NOCHE';
  }
}

function obtenerTurnoContrario(turno) {
    const turnos = {
        'MA√ëANA': 'TARDE',
        'TARDE': 'NOCHE',
        'NOCHE': 'MA√ëANA'
    };
    
    return turnos[turno.toUpperCase()] || 'TARDE';
}
// ==================== REPORTE POR M√ÅQUINA VALIDADA ====================

function generarReporteMaquina(maquinaId, maquinaNombre) {
    if (!currentUser || currentUser.rol !== 'jefe') {
        showAlert('error', 'Permiso denegado', 'Solo los jefes pueden generar reportes');
        return;
    }
    
    // Verificar que la m√°quina est√© validada
    const maquinaElement = document.querySelector(`[data-maquina-id="${maquinaId}"]`);
    if (!maquinaElement) {
        showAlert('error', 'Error', 'No se encontr√≥ la m√°quina en el consolidado');
        return;
    }
    
    const estadoValidacion = maquinaElement.querySelector('.validacion-resumen');
    if (!estadoValidacion || estadoValidacion.style.display === 'none') {
        showAlert('error', 'No validada', 'La m√°quina debe estar validada para generar un reporte');
        return;
    }
    
    const turnoActual = obtenerTurnoActual();
    const turnoDestino = obtenerTurnoContrario(turnoActual);
    const emailDestino = obtenerCorreoPorTurno(turnoDestino);
    
    document.getElementById('modal-message').innerHTML = `
        <strong>¬øGenerar reporte PDF de esta m√°quina?</strong>
        <br><br>
        <div style="background: #fee2e2; padding: 12px; border-radius: 6px; margin: 10px 0;">
            <strong>${maquinaNombre}</strong> (ID: ${maquinaId})
        </div>
        <div style="font-size: 13px; color: #4b5563; margin: 12px 0;">
            <p><strong>Destino del reporte:</strong></p>
            <ul style="margin: 8px 0; padding-left: 20px;">
                <li><strong>Turno:</strong> ${turnoDestino}</li>
                <li><strong>Correo:</strong> ${emailDestino}</li>
                <li><strong>Jefe origen:</strong> ${currentUser.nombre}</li>
                <li><strong>Turno origen:</strong> ${turnoActual}</li>
            </ul>
            <p style="margin: 8px 0; color: #dc2626; font-weight: 600;">
                <i class="fas fa-file-pdf"></i> Se generar√° un reporte PDF detallado y se enviar√° por correo.
            </p>
        </div>
    `;
    
    window.pendingReporteMaquina = {
        maquinaId: maquinaId,
        maquinaNombre: maquinaNombre
    };
    
    document.getElementById('confirm-modal').classList.remove('hidden');
}

function ejecutarGenerarReporteMaquina() {
  if (!window.pendingReporteMaquina) {
    cerrarModal();
    return;
  }
  
  const { maquinaId, maquinaNombre } = window.pendingReporteMaquina;
  
  cerrarModal();
  showLoading();
  
  const turnoActual = obtenerTurnoActual();
  const turnoDestino = obtenerTurnoContrario(turnoActual);
  const procesoUsuario = currentUser.proceso || 'GENERAL';
  
  // Obtener el correo destino CORRECTAMENTE
  const emailDestino = obtenerCorreoPorTurno(turnoDestino);
  
  console.log('üì§ Generando reporte con par√°metros:', {
    maquinaId,
    maquinaNombre,
    jefeOrigenNombre: currentUser.nombre,
    jefeOrigenCedula: currentUser.cedula,
    turnoOrigen: turnoActual,
    turnoDestino,
    procesoUsuario,
    emailDestino  // ‚Üê Aseg√∫rate de que esta variable tenga valor
  });
  
  // Verificar que emailDestino tenga valor
  if (!emailDestino || emailDestino.trim() === '') {
    hideLoading();
    showAlert('error', 'Error', 'No se pudo determinar el correo destino para el turno ' + turnoDestino);
    window.pendingReporteMaquina = null;
    return;
  }
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      if (result && result.success) {
        showAlert("success", "‚úÖ Reporte enviado", 
          `Reporte de "${maquinaNombre}" enviado a:\n${emailDestino}\nTurno: ${turnoDestino}`);
        
        // Recargar el consolidado para reflejar cambios
        loadPlaneaciones();
      } else {
        showAlert('error', 'Error', result ? result.message : 'Error al generar reporte');
      }
      window.pendingReporteMaquina = null;
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showAlert('error', 'Error de conexi√≥n', error.message);
      window.pendingReporteMaquina = null;
    })
    .generarReporteMaquinaPDF(
      maquinaId,
      maquinaNombre,
      currentUser.nombre,
      currentUser.cedula || '',
      turnoActual,
      turnoDestino,
      procesoUsuario,
      emailDestino  // ‚Üê ¬°IMPORTANTE! Pasar emailDestino como octavo par√°metro
    );
}

// ==================== FINALIZAR LIMPIEZA (OPERARIO) ====================

function finalizarLimpiezaMasiva(exitosos, errores) {
    hideLoading();
    
    if (exitosos > 0) {
        showAlert("success", "‚úÖ Limpieza masiva aplicada", 
            `Se procesaron ${exitosos} elementos exitosamente${errores > 0 ? `, ${errores} con errores` : ''}`);
        
        // ¬°SOLUCI√ìN SIMPLE! Recargar sidebar
        actualizarEstadosSidebar();
        
        // Si estamos viendo un elemento que fue limpiado, recargar sus datos
        if (currentElementoId) {
            console.log(`üîÑ Recargando datos del elemento actual (${currentElementoId})`);
            loadElementoTiposLimpieza();
        }
        
        // Limpiar selecci√≥n
        limpiarSeleccionDespuesDeLimpieza();
        
    } else {
        showAlert('error', 'Error', 'No se pudo procesar ning√∫n elemento');
    }
    
    cerrarTodosLosModales();
    window.pendingLimpiezaMasiva = null;
}

function cerrarTodosLosModales() {
    // Cerrar modal de confirmaci√≥n
    document.getElementById('confirm-modal').classList.add('hidden');
    
    // Cerrar modal de limpieza masiva si existe
    const modalLimpiezaMasiva = document.getElementById('limpieza-masiva-modal');
    if (modalLimpiezaMasiva) {
        modalLimpiezaMasiva.classList.add('hidden');
    }
    
    // Limpiar todos los estados pendientes
    window.pendingLimpiezaMasiva = null;
    window.pendingMaquinaDelete = null;
    window.pendingMaquinaValidation = null;
    window.pendingReporteMaquina = null;
    window.pendingFinalizarCompleto = null;
    pendingCheckboxData = null;
    pendingValidation = false;
}

function obtenerTiposLimpiezaPendientes() {
  if (!currentElementoTiposLimpieza || currentElementoTiposLimpieza.length === 0) {
    return [];
  }
  
  const pendientes = currentElementoTiposLimpieza.filter(reg => 
    reg.estado !== 'COMPLETADO' && reg.estado !== 'VALIDADO'
  );
  
  return pendientes.map(reg => reg.tipoLimpieza);
}

function mostrarModalFinalizarLimpieza(tiposPendientes) {
  const tiposNombres = {
    'SECO': 'Limpieza Seco',
    'HUMEDO': 'Limpieza H√∫medo', 
    'DESINFECCION': 'Desinfecci√≥n'
  };
  
  let listaTipos = '';
  tiposPendientes.forEach(tipo => {
    listaTipos += `<li>‚Ä¢ ${tiposNombres[tipo] || tipo}</li>`;
  });
  
  document.getElementById('modal-message').innerHTML = `
    <strong>¬øFinalizar todas las limpiezas pendientes de este elemento?</strong>
    <br><br>
    <div style="background: #f0f9ff; padding: 12px; border-radius: 6px; margin: 10px 0;">
      <div style="font-weight: 600; color: #0369a1; margin-bottom: 4px;">
        <i class="fas fa-industry"></i> ELEMENTO A FINALIZAR:
      </div>
      <div style="color: #0c4a6e; font-size: 14px;">
        <strong>${currentElementoNombre}</strong><br>
        M√°quina: ${currentMaquinaNombre}
      </div>
    </div>
    
    <div style="font-size: 13px; color: #4b5563; margin: 12px 0;">
      <p style="margin: 8px 0;"><i class="fas fa-broom"></i> Limpiezas pendientes:</p>
      <ul style="margin: 8px 0; padding-left: 20px;">
        ${listaTipos}
      </ul>
      <p style="margin: 8px 0; color: #059669; font-weight: 600;">
        <i class="fas fa-check-circle"></i> Esta acci√≥n marcar√° como COMPLETADO todos los tipos de limpieza pendientes.
      </p>
    </div>
  `;
  
  // Cambiar t√≠tulo del modal
  const modalTitle = document.querySelector('.modal-title');
  if (modalTitle) {
    modalTitle.textContent = 'Finalizar Limpieza Completa';
  }
  
  // Configurar botones del modal
  const confirmBtn = document.querySelector('.btn-confirm');
  const cancelBtn = document.querySelector('.btn-cancel');
  
  if (confirmBtn) {
    confirmBtn.textContent = 'Finalizar Todas';
    confirmBtn.style.backgroundColor = '#10b981';
    confirmBtn.style.borderColor = '#10b981';
  }
  
  if (cancelBtn) {
    cancelBtn.textContent = 'Cancelar';
  }
  
  // Mostrar el modal
  document.getElementById('confirm-modal').classList.remove('hidden');
  
  // Configurar callback
  window.pendingFinalizarCompleto = {
    elementoId: currentElementoId,
    tiposPendientes: tiposPendientes
  };
}

function confirmarFinalizarCompleto() {
  if (!window.pendingFinalizarCompleto) return;
  
  const { elementoId, tiposPendientes } = window.pendingFinalizarCompleto;
  
  cerrarModal();
  showLoading();
  
  console.log('üì§ Finalizando limpiezas completas para:', {
    elementoId: elementoId,
    tipos: tiposPendientes,
    responsable: currentUser.nombre
  });
  
  // Obtener fecha actual
  const fechaActual = new Date().toISOString().split('T')[0];
  
  // Para cada tipo pendiente, obtener el registro ID y actualizarlo
  const actualizaciones = tiposPendientes.map(tipo => {
    const registro = currentElementoTiposLimpieza.find(reg => 
      reg.tipoLimpieza === tipo && 
      reg.estado !== 'COMPLETADO' && 
      reg.estado !== 'VALIDADO'
    );
    
    return registro ? {
      registroId: registro.id,
      tipoLimpieza: tipo,
      datos: {
        estado: 'COMPLETADO',
        responsable: currentUser.nombre,
        fechaRealizacion: fechaActual,
        observaciones: 'Finalizado autom√°ticamente desde "Finalizar Limpieza"',
        fechaFinalizacion: new Date().toISOString()
      }
    } : null;
  }).filter(item => item !== null);
  
  console.log('üîÑ Actualizaciones a realizar:', actualizaciones.length);
  
  if (actualizaciones.length === 0) {
    hideLoading();
    showAlert('info', 'Sin cambios', 'No hay limpiezas pendientes para actualizar');
    window.pendingFinalizarCompleto = null;
    return;
  }
  
  // Contador para seguimiento
  let actualizados = 0;
  let errores = 0;
  const total = actualizaciones.length;
  
  // Actualizar cada registro
  actualizaciones.forEach((actualizacion, index) => {
    google.script.run
      .withSuccessHandler(function(result) {
        actualizados++;
        
        if (result && !result.success) {
          errores++;
          console.error(`‚ùå Error en ${actualizacion.tipoLimpieza}:`, result.message);
        } else {
          console.log(`‚úÖ ${actualizacion.tipoLimpieza} completado`);
        }
        
        // Cuando todas las actualizaciones terminen
        if (actualizados + errores === total) {
          hideLoading();
          
          if (errores === 0) {
            showAlert("success", "‚úÖ ¬°√âxito!", 
              `Finalizadas ${actualizados} limpieza(s) para este elemento`);
            
            // Recargar los datos del elemento
            loadElementoTiposLimpieza();
            
            // Actualizar estados en sidebar
            actualizarEstadosSidebar();
            
          } else if (actualizados > 0) {
            showAlert("warning", "Parcialmente completado", 
              `${actualizados} completados, ${errores} errores`);
            
            // Recargar igualmente
            loadElementoTiposLimpieza();
            
          } else {
            showAlert('error', 'Error', `No se pudo finalizar ninguna limpieza`);
          }
          
          window.pendingFinalizarCompleto = null;
        }
      })
      .withFailureHandler(function(error) {
        actualizados++;
        errores++;
        console.error(`‚ùå Error de conexi√≥n en ${actualizacion.tipoLimpieza}:`, error);
        
        if (actualizados + errores === total) {
          hideLoading();
          showAlert('error', 'Error', `Errores al finalizar: ${errores}/${total}`);
          window.pendingFinalizarCompleto = null;
        }
      })
      .actualizarRegistroLimpiezaCompleto(
        actualizacion.registroId,
        actualizacion.datos
      );
  });
}

// ==================== LIMPIEZA MASIVA ====================
function mostrarPanelLimpiezaMasiva() {
    if (elementosSeleccionados.size === 0) {
        showAlert("info", "Seleccione elementos", "Por favor seleccione al menos un elemento del √°rbol");
        return;
    }
    
    // Verificar que todos los elementos seleccionados sean v√°lidos
    let elementosInvalidos = [];
    let elementosPorEstado = {
        pendiente: 0,
        empezado: 0,
        otros: 0
    };
    
    elementosSeleccionados.forEach(elementoId => {
        if (!puedeSeleccionarParaLimpiezaMasiva(elementoId)) {
            elementosInvalidos.push(elementoId);
        } else {
            const estado = determinarEstadoElemento(elementoId);
            if (estado === 'pendiente') {
                elementosPorEstado.pendiente++;
            } else if (estado === 'empezado') {
                elementosPorEstado.empezado++;
            } else {
                elementosPorEstado.otros++;
            }
        }
    });
    
    // Si hay elementos inv√°lidos, mostrar alerta y removerlos
    if (elementosInvalidos.length > 0) {
        showAlert("warning", "Elementos no v√°lidos", 
            `${elementosInvalidos.length} elementos seleccionados no son v√°lidos para limpieza masiva y ser√°n removidos.`);
        
        // Remover los elementos inv√°lidos
        elementosInvalidos.forEach(elementoId => {
            elementosSeleccionados.delete(elementoId);
            delete elementosSeleccionadosData[elementoId];
        });
        
        actualizarContadorSeleccionados();
        renderSidebarMaquinas();
        
        if (elementosSeleccionados.size === 0) {
            showAlert("info", "Sin elementos v√°lidos", "No quedan elementos v√°lidos para limpieza masiva");
            return;
        }
    }
    
    const modal = document.getElementById('limpieza-masiva-modal');
    if (!modal) {
        crearModalLimpiezaMasiva();
    }
    
    // Actualizar informaci√≥n en el modal
    const countSpan = document.getElementById('limpieza-masiva-count');
    if (countSpan) {
        countSpan.textContent = elementosSeleccionados.size;
    }
    
    // Mostrar resumen de estados
    const resumenSpan = document.getElementById('limpieza-masiva-resumen');
    if (resumenSpan) {
        let resumenHTML = '';
        if (elementosPorEstado.pendiente > 0) {
            resumenHTML += `<span style="color: #ef4444;">${elementosPorEstado.pendiente} pendientes</span>`;
        }
        if (elementosPorEstado.empezado > 0) {
            if (resumenHTML) resumenHTML += ', ';
            resumenHTML += `<span style="color: #f59e0b;">${elementosPorEstado.empezado} en proceso</span>`;
        }
        if (elementosPorEstado.otros > 0) {
            if (resumenHTML) resumenHTML += ', ';
            resumenHTML += `<span>${elementosPorEstado.otros} otros</span>`;
        }
        
        resumenSpan.innerHTML = resumenHTML;
    }
    
    // Mostrar lista de elementos seleccionados
    const listaElementos = document.getElementById('limpieza-masiva-lista');
    if (listaElementos) {
        let listaHTML = '';
        const elementosArray = Array.from(elementosSeleccionados).slice(0, 5);
        elementosArray.forEach(elementoId => {
            const elementoData = elementosSeleccionadosData[elementoId];
            if (elementoData) {
                const estado = determinarEstadoElemento(elementoId);
                let estadoBadge = '';
                
                if (estado === 'pendiente') {
                    estadoBadge = '<span class="estado-badge pendiente">PENDIENTE</span>';
                } else if (estado === 'empezado') {
                    estadoBadge = '<span class="estado-badge empezado">EN PROCESO</span>';
                }
                
                listaHTML += `<li>${elementoData.elementoNombre} ${estadoBadge}</li>`;
            }
        });
        
        if (elementosSeleccionados.size > 5) {
            listaHTML += `<li>... y ${elementosSeleccionados.size - 5} m√°s</li>`;
        }
        
        listaElementos.innerHTML = listaHTML;
    }
    
    // Mostrar modal
    document.getElementById('limpieza-masiva-modal').classList.remove('hidden');
}

// En la funci√≥n crearModalLimpiezaMasiva(), corregir los checkboxes:
function crearModalLimpiezaMasiva() {
    const modal = document.createElement('div');
    modal.id = 'limpieza-masiva-modal';
    modal.className = 'modal limpieza-masiva-modal hidden';
    modal.onclick = function(event) {
        if (event.target === this) {
            cerrarModalLimpiezaMasiva();
        }
    };
    
    modal.innerHTML = `
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 class="modal-title">Limpieza Masiva</h3>
                <button class="modal-close" onclick="cerrarModalLimpiezaMasiva()">&times;</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 16px;">
                    <p style="margin-bottom: 4px;">
                        <strong><span id="limpieza-masiva-count">0</span> elementos seleccionados</strong>
                    </p>
                    <p style="font-size: 12px; color: #6b7280;">
                        Estados: <span id="limpieza-masiva-resumen"></span>
                    </p>
                </div>
                
                <div id="limpieza-masiva-lista" style="
                    background: #f9fafb;
                    border-radius: 4px;
                    padding: 8px;
                    margin-bottom: 16px;
                    font-size: 12px;
                    color: #6b7280;
                    max-height: 120px;
                    overflow-y: auto;
                ">
                    <!-- Lista de elementos se insertar√° aqu√≠ -->
                </div>
                
                <div class="form-group">
                    <label class="form-label">Tipos de limpieza a aplicar:</label>
                    <div class="checkbox-group-horizontal">
                        <label class="checkbox-item">
                            <input type="checkbox" id="masiva-seco" checked 
                                onchange="limpiezaMasivaData.seco = this.checked">
                            Limpieza Seco
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="masiva-humedo" checked
                                onchange="limpiezaMasivaData.humedo = this.checked">
                            Limpieza H√∫medo
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="masiva-desinfeccion" checked
                                onchange="limpiezaMasivaData.desinfeccion = this.checked">
                            Desinfecci√≥n
                        </label>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Fecha de realizaci√≥n:</label>
                    <input type="date" class="input-field" id="masiva-fecha" 
                           value="${new Date().toISOString().split('T')[0]}"
                           max="${new Date().toISOString().split('T')[0]}">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Observaciones (opcional):</label>
                    <textarea class="textarea-field" id="masiva-observaciones" 
                              placeholder="Observaciones para todos los elementos..."></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="cerrarModalLimpiezaMasiva()">Cancelar</button>
                <button class="btn-primary" onclick="aplicarLimpiezaMasiva()">Aplicar limpieza</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    
    // Inicializar los datos
    limpiezaMasivaData = {
        seco: true,
        humedo: true,
        desinfeccion: true
    };
}

function cerrarModalLimpiezaMasiva() {
    document.getElementById('limpieza-masiva-modal').classList.add('hidden');
}

function aplicarLimpiezaMasiva() {
    // Validar que haya al menos un tipo de limpieza seleccionado
    if (!limpiezaMasivaData.seco && !limpiezaMasivaData.humedo && !limpiezaMasivaData.desinfeccion) {
        showAlert("info", "Seleccione tipo", "Por favor seleccione al menos un tipo de limpieza");
        return;
    }
    
    const fecha = document.getElementById('masiva-fecha').value;
    if (!fecha) {
        showAlert("info", "Fecha requerida", "Por favor seleccione la fecha de realizaci√≥n");
        return;
    }
    
    const observaciones = document.getElementById('masiva-observaciones').value;
    
    // Primero cerrar el modal de limpieza masiva
    cerrarModalLimpiezaMasiva();
    
    // Luego mostrar el modal de confirmaci√≥n
    setTimeout(() => {
        document.getElementById('modal-message').innerHTML = `
            <strong>¬øAplicar limpieza?</strong>
            <br><br>
            <div style="background: #f0f9ff; padding: 12px; border-radius: 6px; margin: 10px 0;">
                <div style="font-weight: 600; color: #0369a1; margin-bottom: 4px;">
                    <i class="fas fa-broom"></i> RESUMEN DE LIMPIEZA:
                </div>
                <div style="color: #0c4a6e; font-size: 14px;">
                    <strong>${elementosSeleccionados.size} elementos</strong> seleccionados
                </div>
            </div>
            
            <div style="font-size: 13px; color: #4b5563; margin: 12px 0;">
                <p style="margin: 8px 0;">Tipos de limpieza a aplicar:</p>
                <ul style="margin: 8px 0; padding-left: 20px;">
                    ${limpiezaMasivaData.seco ? '<li>‚Ä¢ Limpieza Seco</li>' : ''}
                    ${limpiezaMasivaData.humedo ? '<li>‚Ä¢ Limpieza H√∫medo</li>' : ''}
                    ${limpiezaMasivaData.desinfeccion ? '<li>‚Ä¢ Desinfecci√≥n</li>' : ''}
                </ul>
                <p style="margin: 8px 0;">
                    <strong>Fecha:</strong> ${fecha}<br>
                    <strong>Responsable:</strong> ${currentUser.nombre}
                </p>
                <p style="margin: 8px 0; color: #059669; font-weight: 600;">
                    <i class="fas fa-check-circle"></i> Esta acci√≥n marcar√° como COMPLETADO los tipos seleccionados en todos los elementos.
                </p>
            </div>
        `;
        
        // Configurar el modal de confirmaci√≥n
        const modalTitle = document.querySelector('.modal-title');
        if (modalTitle) {
            modalTitle.textContent = 'Confirmar Limpieza Masiva';
        }
        
        const confirmBtn = document.querySelector('.btn-confirm');
        const cancelBtn = document.querySelector('.btn-cancel');
        
        if (confirmBtn) {
            confirmBtn.textContent = 'Aplicar';
            confirmBtn.style.backgroundColor = '#10b981';
            confirmBtn.style.borderColor = '#10b981';
        }
        
        if (cancelBtn) {
            cancelBtn.textContent = 'Cancelar';
        }
        
        document.getElementById('confirm-modal').classList.remove('hidden');
        
        // Guardar datos para usar en la confirmaci√≥n
        window.pendingLimpiezaMasiva = {
            fecha: fecha,
            observaciones: observaciones
        };
    }, 100); // Peque√±o delay para asegurar el cierre del primer modal
}

function confirmarLimpiezaMasiva() {
    if (!window.pendingLimpiezaMasiva) return;
    
    // Verificar que hay tipos seleccionados
    if (!limpiezaMasivaData.seco && !limpiezaMasivaData.humedo && !limpiezaMasivaData.desinfeccion) {
        showAlert("error", "No hay tipos", "Por favor seleccione al menos un tipo de limpieza");
        return;
    }
    
    debugLimpiezaMasiva(); // Debug
    
    const { fecha, observaciones } = window.pendingLimpiezaMasiva;
    
    // Cerrar ambos modales primero
    document.getElementById('confirm-modal').classList.add('hidden');
    document.getElementById('limpieza-masiva-modal').classList.add('hidden');
    
    showLoading();
    
    // Convertir Set a Array
    const elementosArray = Array.from(elementosSeleccionados);
    
    console.log('üîÑ Iniciando limpieza masiva para', elementosArray.length, 'elementos');
    console.log('Tipos seleccionados:', {
        seco: limpiezaMasivaData.seco,
        humedo: limpiezaMasivaData.humedo,
        desinfeccion: limpiezaMasivaData.desinfeccion
    });
    
    // Si no hay elementos, salir
    if (elementosArray.length === 0) {
        hideLoading();
        showAlert('info', 'Sin elementos', 'No hay elementos seleccionados');
        window.pendingLimpiezaMasiva = null;
        return;
    }
    
    // Contadores para seguimiento
    let procesados = 0;
    let exitosos = 0;
    let errores = 0;
    const total = elementosArray.length;
    
    // Procesar cada elemento
    elementosArray.forEach(elementoId => {
        const elementoData = elementosSeleccionadosData[elementoId];
        if (!elementoData) {
            procesados++;
            if (procesados === total) {
                finalizarLimpiezaMasiva(exitosos, errores);
            }
            return;
        }
        
        console.log(`üì§ Procesando elemento: ${elementoData.elementoNombre}`);
        
        // Obtener registros de limpieza para este elemento
        google.script.run
            .withSuccessHandler(function(result) {
                procesados++;
                
                if (result && result.success && result.registros && result.registros.length > 0) {
                    const registros = result.registros || [];
                    console.log(`‚úÖ Obtenidos ${registros.length} registros para`, elementoData.elementoNombre);
                    
                    // Actualizar registros
                    actualizarRegistrosElemento(registros, elementoData, fecha, observaciones);
                    exitosos++;
                } else {
                    errores++;
                    console.error('‚ùå Error obteniendo registros para', elementoData.elementoNombre, 
                        result ? result.message : 'Sin registros');
                }
                
                // Cuando termine el procesamiento
                if (procesados === total) {
                    setTimeout(() => {
                        finalizarLimpiezaMasiva(exitosos, errores);
                    }, 1000);
                }
            })
            .withFailureHandler(function(error) {
                procesados++;
                errores++;
                console.error('‚ùå Error de conexi√≥n para', elementoData.elementoNombre, error);
                
                if (procesados === total) {
                    setTimeout(() => {
                        finalizarLimpiezaMasiva(exitosos, errores);
                    }, 1000);
                }
            })
            .obtenerRegistrosLimpieza(elementoData.maquinaId, elementoId);
    });
}

function actualizarRegistrosElemento(registros, elementoData, fecha, observaciones) {
    console.log(`üîç DEBUG actualizarRegistrosElemento para ${elementoData.elementoNombre}:`);
    console.log('Registros recibidos:', registros);
    console.log('limpiezaMasivaData:', limpiezaMasivaData);
    
    // Filtrar registros por los tipos seleccionados
    const tiposSeleccionados = [];
    if (limpiezaMasivaData.seco) tiposSeleccionados.push('SECO');
    if (limpiezaMasivaData.humedo) tiposSeleccionados.push('HUMEDO');
    if (limpiezaMasivaData.desinfeccion) tiposSeleccionados.push('DESINFECCION');
    
    console.log('Tipos seleccionados para buscar:', tiposSeleccionados);
    
    // Si no hay tipos seleccionados, mostrar alerta
    if (tiposSeleccionados.length === 0) {
        console.error('‚ùå ERROR: No hay tipos de limpieza seleccionados en limpiezaMasivaData');
        console.error('limpiezaMasivaData actual:', limpiezaMasivaData);
        return;
    }
    
    console.log(`üîÑ Buscando ${tiposSeleccionados.length} tipos para`, elementoData.elementoNombre);
    
    // Para cada tipo seleccionado, encontrar el registro correspondiente
    tiposSeleccionados.forEach(tipo => {
        console.log(`üîç Buscando registro tipo ${tipo}...`);
        
        const registro = registros.find(r => {
            console.log(`  Registro: tipo=${r.tipoLimpieza}, estado=${r.estado}`);
            return r.tipoLimpieza === tipo && 
                   (r.estado !== 'COMPLETADO' && r.estado !== 'VALIDADO');
        });
        
        if (registro) {
            console.log(`‚úÖ Encontrado registro para ${tipo} (ID: ${registro.id}) en`, elementoData.elementoNombre);
            
            const datos = {
                estado: 'COMPLETADO',
                responsable: currentUser.nombre,
                fechaRealizacion: fecha,
                observaciones: observaciones || `Limpieza masiva aplicada el ${fecha}`,
                fechaFinalizacion: new Date().toISOString()
            };
            
            console.log(`üì§ Enviando datos para ${tipo}:`, datos);
            
            // Enviar actualizaci√≥n al servidor
            google.script.run
                .withSuccessHandler(function(result) {
                    if (result && result.success) {
                        console.log(`‚úÖ ${tipo} actualizado para`, elementoData.elementoNombre);
                    } else {
                        console.error(`‚ùå Error actualizando ${tipo} para`, elementoData.elementoNombre, result ? result.message : '');
                    }
                })
                .withFailureHandler(function(error) {
                    console.error(`‚ùå Error de conexi√≥n para ${tipo} en`, elementoData.elementoNombre, error);
                })
                .actualizarRegistroLimpiezaCompleto(registro.id, datos);
        } else {
            console.warn(`‚ö†Ô∏è No se encontr√≥ registro para ${tipo} en`, elementoData.elementoNombre, 
                        'o ya est√° COMPLETADO/VALIDADO');
        }
    });
}


// ==================== FUNCI√ìN PARA SELECCIONAR TODOS ====================
function seleccionarTodosElementosPlaneados() {
    if (!maquinasData) return;
    
    elementosSeleccionados.clear();
    elementosSeleccionadosData = {};
    
    let elementosPlaneadosCount = 0;
    
    // Recorrer todas las m√°quinas, componentes y elementos
    maquinasData.forEach(maquina => {
        if (maquina.componentes) {
            maquina.componentes.forEach(componente => {
                if (componente.elementos) {
                    componente.elementos.forEach(elemento => {
                        if (tienePlaneacionActiva(elemento.id)) {
                            elementosSeleccionados.add(elemento.id);
                            elementosSeleccionadosData[elemento.id] = {
                                elementoId: elemento.id,
                                maquinaId: maquina.id,
                                elementoNombre: elemento.nombre
                            };
                            elementosPlaneadosCount++;
                        }
                    });
                }
            });
        }
    });
    
    // Actualizar UI
    actualizarContadorSeleccionados();
    
    if (elementosPlaneadosCount === 0) {
        showAlert("info", "No hay elementos", "No hay elementos con planeaci√≥n activa para seleccionar");
    } else {
        showAlert("success", "Seleccionados", `${elementosPlaneadosCount} elementos planeados seleccionados`);
    }
    
    // Recargar la sidebar para mostrar los checkboxes marcados
    renderSidebarMaquinas();
}

// ==================== FUNCI√ìN PARA DESELECCIONAR TODOS ====================
function deseleccionarTodosElementos() {
    elementosSeleccionados.clear();
    elementosSeleccionadosData = {};
    
    actualizarContadorSeleccionados();
    renderSidebarMaquinas();
}

function puedeSeleccionarParaLimpiezaMasiva(elementoId) {
    const estado = determinarEstadoElemento(elementoId);
    
    // Solo se puede seleccionar si est√° en estado PENDIENTE o EN-PROCESO
    // Esto significa que tiene planeaci√≥n pero a√∫n no est√° completado
    return estado === 'pendiente' || estado === 'empezado'; // 'empezado' = EN-PROCESO
}

function seleccionarTodosElementosPendientes() {
    if (!maquinasData) return;
    
    elementosSeleccionados.clear();
    elementosSeleccionadosData = {};
    
    let elementosSeleccionablesCount = 0;
    
    // Recorrer todas las m√°quinas, componentes y elementos
    maquinasData.forEach(maquina => {
        if (maquina.componentes) {
            maquina.componentes.forEach(componente => {
                if (componente.elementos) {
                    componente.elementos.forEach(elemento => {
                        if (puedeSeleccionarParaLimpiezaMasiva(elemento.id)) {
                            elementosSeleccionados.add(elemento.id);
                            elementosSeleccionadosData[elemento.id] = {
                                elementoId: elemento.id,
                                maquinaId: maquina.id,
                                elementoNombre: elemento.nombre
                            };
                            elementosSeleccionablesCount++;
                        }
                    });
                }
            });
        }
    });
    
    // Actualizar UI
    actualizarContadorSeleccionados();
    
    if (elementosSeleccionablesCount === 0) {
        showAlert("info", "No hay elementos", "No hay elementos pendientes o en proceso para seleccionar");
    } else {
        showAlert("success", "Seleccionados", `${elementosSeleccionablesCount} elementos pendientes/en proceso seleccionados`);
    }
    
    // Recargar la sidebar para mostrar los checkboxes marcados
    renderSidebarMaquinas();
}

async function obtenerEstadosDesdeConsolidado() {
    return new Promise((resolve) => {
        if (currentUser.proceso === 'GENERAL') {
            google.script.run
                .withSuccessHandler(function(result) {
                    const estadosMap = {};
                    
                    if (result && result.success && result.planeaciones) {
                        result.planeaciones.forEach(planeacion => {
                            // Aqu√≠ deber√≠as mapear los elementos de las planeaciones
                            // Esto depende de c√≥mo est√© estructurado tu consolidado
                        });
                    }
                    
                    resolve(estadosMap);
                })
                .obtenerTodasLasPlaneaciones();
        } else {
            google.script.run
                .withSuccessHandler(function(result) {
                    const estadosMap = {};
                    
                    if (result && result.success && result.planeaciones) {
                        result.planeaciones.forEach(planeacion => {
                            // Mapear estados de elementos
                        });
                    }
                    
                    resolve(estadosMap);
                })
                .obtenerPlaneacionesPorProceso(currentUser.proceso);
        }
    });
}

function toggleElementoSelection(maquinaId, elementoId, maquinaNombre, elementoNombre, componenteNombre) {
  const elemCheck = document.getElementById('check-elem-' + elementoId);
  if (!elemCheck) return;
  
  const isChecked = elemCheck.checked;
  
  if (isChecked) {
    addElementoToConfig(maquinaId, elementoId, maquinaNombre, elementoNombre, componenteNombre);
  } else {
    removeElementoFromConfig(elementoId);
  }
  
  // Actualizar estado del componente y m√°quina
  const maquina = maquinasData.find(m => m.id.toString() === maquinaId.toString());
  if (maquina && maquina.componentes) {
    // Encontrar a qu√© componente pertenece este elemento
    for (const componente of maquina.componentes) {
      const elemento = componente.elementos.find(e => e.id.toString() === elementoId.toString());
      if (elemento) {
        updateComponenteCheckState(maquinaId, componente.id);
        break;
      }
    }
  }
  
  updateMaquinaCheckState(maquinaId);
  updateElementosConfigUI();
}

function selectElementoFromSidebar(maquinaId, elementoId, maquinaNombre, elementoNombre, componenteNombre) {
  // Directamente llamar a la funci√≥n de selecci√≥n individual
  selectElemento(maquinaId, elementoId, maquinaNombre, elementoNombre, componenteNombre);
}

function limpiarSeleccionMasiva() {
  elementosSeleccionados.clear();
  elementosSeleccionadosData = {};
  actualizarContadorSeleccionados();
  
  // Limpiar checkboxes en sidebar
  document.querySelectorAll('.sidebar-checkbox:checked').forEach(checkbox => {
    checkbox.checked = false;
  });
  
  // Limpiar clases selected
  document.querySelectorAll('.elemento-item.selected').forEach(item => {
    item.classList.remove('selected');
  });
}


function actualizarEstadoCheckboxes() {
  // Verificar todos los checkboxes en sidebar
  document.querySelectorAll('.sidebar-checkbox').forEach(checkbox => {
    const elementoId = checkbox.id.replace('check-', '');
    const puedeSeleccionar = puedeSeleccionarParaLimpiezaMasiva(elementoId);
    
    if (!puedeSeleccionar) {
      checkbox.disabled = true;
      checkbox.parentElement.classList.add('no-seleccionable');
      checkbox.parentElement.classList.remove('seleccionable');
    } else {
      checkbox.disabled = false;
      checkbox.parentElement.classList.add('seleccionable');
      checkbox.parentElement.classList.remove('no-seleccionable');
    }
  });
}

function verificarConsolidadoParaReporte(maquinaId) {
    return new Promise((resolve) => {
        // Verificar si la m√°quina est√° en el consolidado
        const maquinaElement = document.querySelector(`[data-maquina-id="${maquinaId}"]`);
        
        if (!maquinaElement) {
            resolve({
                success: false,
                message: 'M√°quina no encontrada en el consolidado'
            });
            return;
        }
        
        // Verificar si est√° validada
        const estadoValidacion = maquinaElement.querySelector('.validacion-resumen');
        const estaValidada = estadoValidacion && estadoValidacion.style.display !== 'none';
        
        if (!estaValidada) {
            resolve({
                success: false,
                message: 'La m√°quina no est√° validada'
            });
            return;
        }
        
        // Obtener informaci√≥n de validaci√≥n
        const validador = maquinaElement.querySelector(`#validador-${maquinaId}`)?.textContent || 'Desconocido';
        const fechaValidacion = maquinaElement.querySelector(`#fecha-validacion-${maquinaId}`)?.textContent || 'Desconocida';
        
        resolve({
            success: true,
            datos: {
                validador: validador,
                fechaValidacion: fechaValidacion,
                estaValidada: true
            }
        });
    });
}

const CORREOS_POR_TURNO = {
    'MA√ëANA': 'pragestionhumana@pastascomarrico.com',
    'TARDE': 'pragestionhumana@pastascomarrico.com',
    'NOCHE': 'pragestionhumana@pastascomarrico.com'
};

function obtenerCorreoPorTurno(turno) {
    turno = turno.toUpperCase();
    return CORREOS_POR_TURNO[turno] || 'pragestionhumana@pastascomarrico.com'; // Valor por defecto
}

function handleCheckboxClick(elementoId, maquinaId, elementoNombre, event) {
    event.stopPropagation();
    
    const checkbox = event.target;
    const isChecked = checkbox.checked;
    
    // Verificar si el elemento puede seleccionarse
    if (!puedeSeleccionarParaLimpiezaMasiva(elementoId)) {
        const estado = determinarEstadoElemento(elementoId);
        let mensaje = '';
        
        switch(estado) {
            case 'no-planeado':
                mensaje = "Este elemento no tiene planeaci√≥n activa";
                break;
            case 'terminado':
            case 'en-proceso':
                mensaje = "Este elemento ya tiene limpieza completada o validada";
                break;
            default:
                mensaje = "Este elemento no se puede seleccionar para limpieza masiva";
        }
        
        showAlert("info", "No seleccionable", mensaje);
        checkbox.checked = false;
        return;
    }
    
    // Actualizar la selecci√≥n
    if (isChecked) {
        elementosSeleccionados.add(elementoId);
        elementosSeleccionadosData[elementoId] = {
            elementoId: elementoId,
            maquinaId: maquinaId,
            elementoNombre: elementoNombre,
            estado: determinarEstadoElemento(elementoId)
        };
    } else {
        elementosSeleccionados.delete(elementoId);
        delete elementosSeleccionadosData[elementoId];
    }
    
    // Actualizar apariencia del elemento
    const elementoDiv = checkbox.closest('.elemento-item');
    if (elementoDiv) {
        if (isChecked) {
            elementoDiv.classList.add('selected');
        } else {
            elementoDiv.classList.remove('selected');
        }
    }
    
    actualizarContadorSeleccionados();
}

// Nueva funci√≥n para manejar clic en el elemento (sin checkbox)
function handleElementoSelection(elementoId, maquinaId, elementoNombre, event) {
    // Si se hizo click en el checkbox, ya fue manejado por handleCheckboxClick
    if (event.target.type === 'checkbox') {
        return;
    }
    
    // Verificar si el elemento puede seleccionarse
    if (!puedeSeleccionarParaLimpiezaMasiva(elementoId)) {
        // Si no se puede seleccionar para limpieza masiva, ir a limpieza individual
        selectElementoFromSidebar(maquinaId, elementoId, '', elementoNombre, '');
        return;
    }
    
    // Para limpieza masiva, alternar el estado del checkbox
    const checkbox = document.getElementById(`sidebar-check-${elementoId}`);
    if (checkbox) {
        checkbox.checked = !checkbox.checked;
        
        // Disparar el evento del checkbox
        const fakeEvent = {
            target: checkbox,
            stopPropagation: function() {}
        };
        handleCheckboxClick(elementoId, maquinaId, elementoNombre, fakeEvent);
    }
}

function cerrarModalLimpiezaMasiva() {
    const modal = document.getElementById('limpieza-masiva-modal');
    if (modal) {
        modal.classList.add('hidden');
        
        // NO resetear limpiezaMasivaData aqu√≠, mantener el estado
        // Solo limpiar los campos de fecha y observaciones
        
        // Limpiar campos
        const fechaInput = document.getElementById('masiva-fecha');
        const observacionesInput = document.getElementById('masiva-observaciones');
        
        if (fechaInput) fechaInput.value = new Date().toISOString().split('T')[0];
        if (observacionesInput) observacionesInput.value = '';
    }
}

function limpiarDatosDuplicados() {
    if (!maquinasData || maquinasData.length === 0) return;
    
    console.log('üßπ Limpiando datos duplicados...');
    
    // Usar un Map para eliminar m√°quinas duplicadas por ID
    const maquinasUnicas = new Map();
    
    maquinasData.forEach(maquina => {
        const maquinaKey = maquina.id ? maquina.id.toString() : maquina.nombre;
        if (!maquinasUnicas.has(maquinaKey)) {
            maquinasUnicas.set(maquinaKey, maquina);
        } else {
            console.warn(`‚ö†Ô∏è M√°quina duplicada eliminada: ${maquina.nombre} (ID: ${maquina.id})`);
        }
    });
    
    // Actualizar maquinasData con datos limpios
    const maquinasLimpias = Array.from(maquinasUnicas.values());
    
    // Verificar que no haya m√°quinas con el mismo nombre
    const nombresUnicos = new Set();
    const maquinasFinales = [];
    
    maquinasLimpias.forEach(maquina => {
        if (!nombresUnicos.has(maquina.nombre)) {
            nombresUnicos.add(maquina.nombre);
            maquinasFinales.push(maquina);
        } else {
            console.warn(`‚ö†Ô∏è M√°quina con nombre duplicado eliminada: ${maquina.nombre}`);
        }
    });
    
    maquinasData = maquinasFinales;
    console.log(`‚úÖ Datos limpiados: ${maquinasData.length} m√°quinas √∫nicas`);
}

function debugDuplicacion() {
    console.log('üêõ DEBUG - Causas posibles de duplicaci√≥n:');
    console.log('1. maquinasData length:', maquinasData ? maquinasData.length : 0);
    
    if (maquinasData) {
        const nombres = maquinasData.map(m => m.nombre);
        const duplicados = nombres.filter((nombre, index) => nombres.indexOf(nombre) !== index);
        console.log('2. Nombres duplicados:', [...new Set(duplicados)]);
        
        const ids = maquinasData.map(m => m.id);
        const idsDuplicados = ids.filter((id, index) => ids.indexOf(id) !== index);
        console.log('3. IDs duplicados:', [...new Set(idsDuplicados)]);
    }
    
    const sidebarContainer = document.getElementById('maquinas-menu');
    const maquinasEnDOM = sidebarContainer.querySelectorAll('.submenu-wrapper');
    console.log('4. M√°quinas en DOM:', maquinasEnDOM.length);
    
    console.log('5. isRenderingSidebar:', isRenderingSidebar);
}

function recargarSidebar() {
    console.log('üîÑ Recargando sidebar...');
    
    // Limpiar selecci√≥n
    limpiarSeleccionMasiva();
    
    showLoading();
    
    // Recargar datos desde el servidor
    google.script.run
        .withSuccessHandler(function(result) {
            if (result && result.success) {
                maquinasData = result.maquinas || [];
                limpiarDatosDuplicados();
                // Cargar estados y actualizar sidebar
                cargarEstadosElementos().then(() => {
                    // renderSidebarMaquinas ya se llama dentro de cargarEstadosElementos
                    hideLoading();
                });
            } else {
                hideLoading();
                showAlert('error', 'Error', 'No se pudieron cargar los datos');
            }
        })
        .withFailureHandler(function(error) {
            hideLoading();
            showAlert('error', 'Error de conexi√≥n', error.message);
        })
        .obtenerMaquinasConElementos(currentUser.proceso);
}

// Agregar esta funci√≥n despu√©s de limpiarSeleccionMasiva
function limpiarSeleccionDespuesDeLimpieza() {
    console.log('üßπ Limpiando selecci√≥n despu√©s de limpieza...');
    
    // Desmarcar checkboxes en sidebar
    elementosSeleccionados.forEach(elementoId => {
        const checkbox = document.getElementById(`sidebar-check-${elementoId}`);
        if (checkbox) {
            checkbox.checked = false;
            const elementoDiv = checkbox.closest('.elemento-item');
            if (elementoDiv) {
                elementoDiv.classList.remove('selected');
            }
        }
    });
    
    // Limpiar datos
    elementosSeleccionados.clear();
    elementosSeleccionadosData = {};
    actualizarContadorSeleccionados();
    
    console.log('‚úÖ Selecci√≥n limpiada');
}

function debugLimpiezaMasiva() {
    console.log('üîç DEBUG Limpieza Masiva:');
    console.log('1. limpiezaMasivaData:', limpiezaMasivaData);
    console.log('2. Elementos seleccionados:', elementosSeleccionados.size);
    console.log('3. Tipos seleccionados:', {
        seco: limpiezaMasivaData.seco,
        humedo: limpiezaMasivaData.humedo,
        desinfeccion: limpiezaMasivaData.desinfeccion
    });
}

function obtenerRegistrosLimpieza(maquinaId, elementoId) {
  try {
    console.log('üîç === INICIANDO B√öSQUEDA DE REGISTROS ===');
    console.log('Usuario actual:', currentUser);
    
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEETS.REGISTROS_LIMPIEZA);
    
    if (!sheet) {
      console.log('‚ùå Hoja REGISTROS_LIMPIEZA no encontrada');
      return { success: true, registros: [] };
    }
    
    const data = sheet.getDataRange().getValues();
    console.log('üìä Total filas en REGISTROS_LIMPIEZA:', data.length);
    
    if (data.length <= 1) {
      console.log('‚ÑπÔ∏è Solo hay encabezados en registros');
      return { success: true, registros: [] };
    }
    
    // Buscar √≠ndice de columna RESPONSABLE_ASIGNADO (puede estar en diferente posici√≥n)
    const headers = data[0];
    const responsableAsignadoCol = headers.indexOf('RESPONSABLE_ASIGNADO');
    console.log('üîç Columna RESPONSABLE_ASIGNADO:', responsableAsignadoCol);
    
    const registros = [];
    const maquinaIdBusqueda = maquinaId ? maquinaId.toString().trim() : null;
    const elementoIdBusqueda = elementoId ? elementoId.toString().trim() : null;
    
    let coincidencias = 0;
    
        for (let i = 1; i < data.length; i++) {
      if (!data[i][0] || data[i][0].toString().trim() === '') continue;
      
      const regMaquinaId = data[i][2] ? data[i][2].toString().trim() : '';
      const regElementoId = data[i][4] ? data[i][4].toString().trim() : '';
      
      const matchMaquina = !maquinaIdBusqueda || regMaquinaId === maquinaIdBusqueda;
      const matchElemento = !elementoIdBusqueda || regElementoId === elementoIdBusqueda;
      
      if (matchMaquina && matchElemento) {
        // Formatear fechas
        const fechaCreacion = data[i][11] ? formatearFechaCompleta(data[i][11]) : '';
        const fechaFinalizacion = data[i][12] ? formatearFechaCompleta(data[i][12]) : '';
        const fechaRealizacion = data[i][9] ? formatearFechaCompleta(data[i][9]) : '';
        const fechaValidacion = data[i][15] ? formatearFechaCompleta(data[i][15]) : '';
        
        const registro = {
          id: data[i][0].toString(),
          planeacionId: data[i][1] ? data[i][1].toString() : '',
          maquinaId: regMaquinaId,
          maquinaNombre: data[i][3] || '',
          elementoId: regElementoId,
          elementoNombre: data[i][5] || '',
          tipoLimpieza: data[i][6] || '',
          estado: data[i][7] || 'PENDIENTE',
          responsable: data[i][8] || '',
          fechaRealizacion: fechaRealizacion,
          observaciones: data[i][10] || '',
          fechaCreacion: fechaCreacion,
          fechaFinalizacion: fechaFinalizacion,
          componente: data[i][13] || '',
          validadoPor: data[i][14] || '',
          fechaValidacion: fechaValidacion,
          // NUEVO: Agregar responsableAsignado
          responsableAsignado: data[i][16] ? data[i][16].toString() : 'OPERARIO'
        };
        
        console.log(`‚úÖ REGISTRO COINCIDE ${++coincidencias}:`, {
          id: registro.id,
          elementoNombre: registro.elementoNombre,
          tipoLimpieza: registro.tipoLimpieza,
          estado: registro.estado,
          responsableAsignado: registro.responsableAsignado
        });
        
        registros.push(registro);
      }
    }
    
    console.log('üéØ RESULTADO B√öSQUEDA:');
    console.log('- Total registros retornados:', registros.length);
    
    return { 
      success: true, 
      registros: registros,
      message: `${registros.length} registros encontrados`
    };
    
  } catch (error) {
    console.error('üí• Error cr√≠tico en obtenerRegistrosLimpieza:', error);
    return { 
      success: false, 
      message: 'Error al obtener registros: ' + error.message, 
      registros: [] 
    };
  }
}

// Funci√≥n para cambiar frecuencia individual
function cambiarFrecuenciaIndividual(maquinaId, maquinaNombre, nuevaFrecuencia) {
  // Solo validar que sea jefe, pero no hacer nada m√°s
  // La acci√≥n real la har√° el bot√≥n "Guardar"
  console.log('Frecuencia seleccionada:', { maquinaId, maquinaNombre, nuevaFrecuencia });
}

function guardarFrecuencia(maquinaId, maquinaNombre) {
  if (!currentUser || currentUser.rol !== 'jefe') {
    showAlert('error', 'Permiso denegado', 'Solo los jefes pueden cambiar la frecuencia');
    return;
  }
  
  const select = document.getElementById('frecuencia-' + maquinaId);
  if (!select) return;
  
  const nuevaFrecuencia = select.value;
  
  // Validar frecuencia
  const frecuenciasPermitidas = ['Mensual', 'Trimestral', 'Semestral', 'Anual'];
  if (!frecuenciasPermitidas.includes(nuevaFrecuencia)) {
    showAlert('error', 'Frecuencia no v√°lida', 'Seleccione una frecuencia v√°lida');
    return;
  }
  
  // Configurar y mostrar el modal de confirmaci√≥n
  document.getElementById('modal-message').innerHTML = `
    <strong>¬øCambiar frecuencia de la m√°quina?</strong>
    <br><br>
    <div style="background: #f0f9ff; padding: 12px; border-radius: 6px; margin: 10px 0;">
      <div style="font-weight: 600; color: #0369a1; margin-bottom: 4px;">
        <i class="fas fa-industry"></i> M√ÅQUINA:
      </div>
      <div style="color: #0c4a6e; font-size: 14px;">
        <strong>${maquinaNombre}</strong> (ID: ${maquinaId})
      </div>
    </div>
    
    <div style="font-size: 13px; color: #4b5563; margin: 12px 0;">
      <p style="margin: 8px 0;">
        <strong>Frecuencia actual:</strong> ${select.options[select.selectedIndex].text}
      </p>
      <p style="margin: 8px 0;">
        <strong>Nueva frecuencia:</strong> 
        <span style="color: #059669; font-weight: 600;">${nuevaFrecuencia}</span>
      </p>
      <p style="margin: 8px 0; color: #dc2626; font-weight: 600;">
        <i class="fas fa-exclamation-circle"></i> 
        ¬°Esta acci√≥n actualizar√° todas las planeaciones de esta m√°quina!
      </p>
    </div>
  `;
  
  // Cambiar el t√≠tulo del modal
  const modalTitle = document.querySelector('.modal-title');
  if (modalTitle) {
    modalTitle.textContent = 'Cambiar Frecuencia';
  }
  
  // Configurar los botones del modal
  const confirmBtn = document.querySelector('.btn-confirm');
  const cancelBtn = document.querySelector('.btn-cancel');
  
  if (confirmBtn) {
    confirmBtn.textContent = 'Cambiar Frecuencia';
    confirmBtn.style.backgroundColor = '';
    confirmBtn.style.borderColor = '';
    confirmBtn.disabled = false;
    confirmBtn.style.opacity = '1';
    confirmBtn.style.cursor = 'pointer';
    
    // Configurar el evento onclick para este contexto espec√≠fico
    confirmBtn.onclick = function() {
      // Cerrar modal primero
      document.getElementById('confirm-modal').classList.add('hidden');
      // Aplicar cambio
      aplicarCambioFrecuencia(maquinaId, maquinaNombre, nuevaFrecuencia);
    };
  }
  
  if (cancelBtn) {
    cancelBtn.textContent = 'Cancelar';
    cancelBtn.onclick = function() {
      // Si cancela, restaurar valor anterior y cerrar modal
      obtenerFrecuenciaActualYRestaurar(maquinaId);
      cerrarModal();
    };
  }
  
  // Mostrar el modal
  document.getElementById('confirm-modal').classList.remove('hidden');
  
  // Guardar el ID de la m√°quina para restaurar si se cancela
  window.pendingFrecuenciaChange = {
    maquinaId: maquinaId,
    maquinaNombre: maquinaNombre,
    nuevaFrecuencia: nuevaFrecuencia
  };
}

// Funci√≥n para aplicar el cambio
function aplicarCambioFrecuencia(maquinaId, maquinaNombre, nuevaFrecuencia) {
  showLoading();
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      if (result && result.success) {
        showAlert("success", "‚úÖ Frecuencia actualizada", 
          `"${maquinaNombre}" ahora tiene frecuencia: ${nuevaFrecuencia}`);
        
        // Recargar el consolidado para ver cambios
        setTimeout(() => {
          loadPlaneaciones();
        }, 1000);
      } else {
        showAlert('error', 'Error', result ? result.message : 'Error al cambiar frecuencia');
        // Restaurar valor anterior
        obtenerFrecuenciaActualYRestaurar(maquinaId);
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showAlert('error', 'Error de conexi√≥n', error.message);
      obtenerFrecuenciaActualYRestaurar(maquinaId);
    })
    .cambiarFrecuenciaPlaneacion(maquinaId, nuevaFrecuencia);
}

// Funci√≥n para restaurar frecuencia anterior
function obtenerFrecuenciaActualYRestaurar(maquinaId) {
  google.script.run
    .withSuccessHandler(function(result) {
      if (result && result.success) {
        const select = document.getElementById('frecuencia-' + maquinaId);
        if (select) {
          select.value = result.frecuencia;
        }
      }
    })
    .obtenerFrecuenciaActual(maquinaId);
}

// Funci√≥n para cambiar frecuencia individual
function cambiarFrecuenciaIndividual(maquinaId, maquinaNombre, nuevaFrecuencia) {
  // Solo validar que sea jefe, pero no hacer nada m√°s
  // La acci√≥n real la har√° el bot√≥n "Guardar"
  console.log('Frecuencia seleccionada:', { maquinaId, maquinaNombre, nuevaFrecuencia });
}

// Funci√≥n para aplicar el cambio
function aplicarCambioFrecuencia(maquinaId, maquinaNombre, nuevaFrecuencia) {
  showLoading();
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      if (result && result.success) {
        showAlert("success", "‚úÖ Frecuencia actualizada", 
          `"${maquinaNombre}" ahora tiene frecuencia: ${nuevaFrecuencia}`);
        
        // Recargar el consolidado para ver cambios
        setTimeout(() => {
          loadPlaneaciones();
        }, 1000);
      } else {
        showAlert('error', 'Error', result ? result.message : 'Error al cambiar frecuencia');
        // Restaurar valor anterior
        obtenerFrecuenciaActualYRestaurar(maquinaId);
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showAlert('error', 'Error de conexi√≥n', error.message);
      obtenerFrecuenciaActualYRestaurar(maquinaId);
    })
    .cambiarFrecuenciaPlaneacion(maquinaId, nuevaFrecuencia);
}

// Funci√≥n para restaurar frecuencia anterior
function obtenerFrecuenciaActualYRestaurar(maquinaId) {
  google.script.run
    .withSuccessHandler(function(result) {
      if (result && result.success) {
        const select = document.getElementById('frecuencia-' + maquinaId);
        if (select) {
          select.value = result.frecuencia;
        }
      }
    })
    .obtenerFrecuenciaActual(maquinaId);
}

</script>


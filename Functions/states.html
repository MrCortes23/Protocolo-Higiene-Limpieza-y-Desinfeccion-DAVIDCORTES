<script>
    
// FunciÃ³n para cargar todos los estados de elementos
function cargarEstadosElementos() {
  return new Promise((resolve) => {
    console.log('ðŸ”„ Cargando estados de elementos...');
    
    // Reset cache
    estadosElementosCache = {};
    
    // Obtener todos los registros de limpieza
    google.script.run
      .withSuccessHandler(function(result) {
        if (result && result.success) {
          const registros = result.registros || [];
          
          // Agrupar registros por elemento
          const registrosPorElemento = {};
          registros.forEach(registro => {
            const elementoId = registro.elementoId;
            if (!registrosPorElemento[elementoId]) {
              registrosPorElemento[elementoId] = [];
            }
            registrosPorElemento[elementoId].push(registro);
          });
          
          // Determinar estado de cada elemento
          Object.keys(registrosPorElemento).forEach(elementoId => {
            const registrosElemento = registrosPorElemento[elementoId];
            estadosElementosCache[elementoId] = determinarEstadoPorRegistros(registrosElemento);
          });
          
          console.log('âœ… Estados cargados para', Object.keys(estadosElementosCache).length, 'elementos');
          resolve();
        } else {
          console.log('âš ï¸ No se pudieron cargar estados');
          resolve();
        }
      })
      .withFailureHandler(function(error) {
        console.error('âŒ Error cargando estados:', error);
        resolve();
      })
      .obtenerRegistrosLimpiezaPorProceso(null, null);
  });
}

// FunciÃ³n para determinar estado de un elemento basado en sus registros
function determinarEstadoPorRegistros(registros) {
  if (!registros || registros.length === 0) {
    return 'no-planeado'; // ROJO - No tiene registros
  }
  
  const totalRegistros = registros.length;
  const completados = registros.filter(r => r.estado === 'COMPLETADO').length;
  const validados = registros.filter(r => r.validadoPor && r.validadoPor !== '').length;
  
  if (validados > 0) {
    return 'terminado'; // AZUL - Validado por jefe
  } else if (completados === totalRegistros) {
    return 'en-proceso'; // VERDE - Todos completados pero no validados
  } else if (completados > 0) {
    return 'empezado'; // AMARILLO - Algunos completados
  } else {
    return 'no-planeado'; // ROJO - Planeado pero no empezado
  }
}

// FunciÃ³n para obtener estado de un elemento especÃ­fico
function determinarEstadoElemento(elementoId) {
  if (estadosElementosCache[elementoId]) {
    return estadosElementosCache[elementoId];
  }
  return 'no-planeado'; // Por defecto
}

// FunciÃ³n para determinar estado de un componente
function determinarEstadoComponente(maquinaId, componenteId) {
  const maquina = maquinasData.find(m => m.id.toString() === maquinaId.toString());
  if (!maquina || !maquina.componentes) return 'no-planeado';
  
  const componente = maquina.componentes.find(c => c.id.toString() === componenteId.toString());
  if (!componente || !componente.elementos) return 'no-planeado';
  
  const estadosElementos = componente.elementos.map(elem => 
    determinarEstadoElemento(elem.id)
  );
  
  // Si todos los elementos estÃ¡n terminados
  if (estadosElementos.every(estado => estado === 'terminado')) {
    return 'terminado';
  }
  
  // Si todos estÃ¡n en proceso
  if (estadosElementos.every(estado => estado === 'en-proceso')) {
    return 'en-proceso';
  }
  
  // Si hay al menos uno empezado
  if (estadosElementos.some(estado => estado === 'empezado' || estado === 'en-proceso' || estado === 'terminado')) {
    return 'empezado';
  }
  
  return 'no-planeado';
}

// FunciÃ³n para determinar estado de una mÃ¡quina
function determinarEstadoMaquina(maquinaId) {
  const maquina = maquinasData.find(m => m.id.toString() === maquinaId.toString());
  if (!maquina || !maquina.componentes) return 'no-planeado';
  
  const estadosComponentes = maquina.componentes.map(componente => 
    determinarEstadoComponente(maquinaId, componente.id)
  );
  
  // Si todos los componentes estÃ¡n terminados
  if (estadosComponentes.every(estado => estado === 'terminado')) {
    return 'terminado';
  }
  
  // Si todos estÃ¡n en proceso
  if (estadosComponentes.every(estado => estado === 'en-proceso')) {
    return 'en-proceso';
  }
  
  // Si hay al menos uno empezado
  if (estadosComponentes.some(estado => estado === 'empezado' || estado === 'en-proceso' || estado === 'terminado')) {
    return 'empezado';
  }
  
  return 'no-planeado';
}

// FunciÃ³n para actualizar estados despuÃ©s de cambios
function actualizarEstadosSidebar() {
  console.log('ðŸ”„ Actualizando estados del sidebar...');
  cargarEstadosElementos().then(() => {
    renderSidebarMaquinas();
  });
}

function refrescarEstados() {
  showAlert("info", "Actualizando", "Refrescando estados de elementos...");
  actualizarEstadosSidebar();
}

function actualizarIndicadorProceso() {
  const container = document.getElementById('proceso-indicator');
  if (!container) return;
  
  const procesos = {
    'PASTIFICIO': { nombre: 'Pastificio', color: '#ef4444' },
    'EMPAQUE': { nombre: 'Empaque', color: '#10b981' },
    'MANTENIMIENTO': { nombre: 'Mantenimiento', color: '#f59e0b' },
    'CALIDAD': { nombre: 'Calidad', color: '#8b5cf6' },
    'GENERAL': { nombre: 'General', color: '#6b7280' }
  };
  
  const proceso = currentUser.proceso || 'GENERAL';
  const info = procesos[proceso] || { nombre: proceso, color: '#6b7280' };
  
  container.innerHTML = `
    <span>Proceso: </span>
    <span class="proceso-badge" style="background: ${info.color}">
      ${info.nombre}
    </span>
  `;
}

</script>